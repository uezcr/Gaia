# 可拖拽窗口系统完成总结

## 已完成工作

### 1. 核心类实现 ✅

#### UGaiaDraggableWindow (窗口基类)

**文件**：
- `Source/Gaia/UI/GaiaDraggableWindow.h` (202行)
- `Source/Gaia/UI/GaiaDraggableWindow.cpp` (311行)

**核心功能**：
- ✅ 使用 `GaiaDraggableTitleBar` 实现拖动
- ✅ 完美解决 `AddToViewport()` 的满屏问题
- ✅ 自动大小和位置控制
- ✅ 居中显示支持
- ✅ 内容槽位（`NamedSlot`）
- ✅ 关闭按钮和事件
- ✅ 大小限制（最小/最大）
- ✅ 位置保存接口（预留）
- ✅ 完全可配置的窗口样式

---

## 核心特性详解

### 1. 解决 `AddToViewport` 满屏问题

**问题**：
```cpp
// 用户的困惑
CreateWidget(...)
  ↓
AddToViewport()  // 为什么窗口总是满屏？
```

**原因**：
`AddToViewport()` 默认将 Widget 的 Desired Size 设置为整个视口大小，并且：
- `SetAlignmentInViewport` 默认为 `(0, 0)`（但实际会填充整个视口）
- 没有调用 `SetDesiredSizeInViewport()`
- 没有调用 `SetPositionInViewport()`

**解决方案**：

`ShowWindow()` 函数正确地设置了这三个关键属性：

```cpp
void UGaiaDraggableWindow::ShowWindow()
{
    // 1. 添加到视口
    AddToViewport();

    // 2. 设置对齐方式为左上角（关键！）
    SetAlignmentInViewport(FVector2D(0.0f, 0.0f));

    // 3. 设置窗口大小（关键！）
    FVector2D ClampedSize = ClampWindowSize(DefaultWindowSize);
    SetDesiredSizeInViewport(ClampedSize);

    // 4. 设置窗口位置（关键！）
    if (bAutoCenterOnShow)
    {
        CenterWindow(); // 居中显示
    }
    else
    {
        SetPositionInViewport(DefaultWindowPosition, false);
    }
}
```

**关键API**：
- `SetAlignmentInViewport(FVector2D(0, 0))` - 左上角对齐
- `SetDesiredSizeInViewport(Size)` - 设置期望大小
- `SetPositionInViewport(Position)` - 设置位置

### 2. 居中显示

```cpp
void UGaiaDraggableWindow::CenterWindow()
{
    // 获取视口大小
    FVector2D ViewportSize;
    GEngine->GameViewport->GetViewportSize(ViewportSize);

    // 计算居中位置
    FVector2D WindowSize = DefaultWindowSize;
    FVector2D Position = (ViewportSize - WindowSize) * 0.5f;

    // 确保不出屏幕
    Position.X = FMath::Max(0.0f, Position.X);
    Position.Y = FMath::Max(0.0f, Position.Y);

    // 设置位置
    SetPositionInViewport(Position, false);
}
```

### 3. 组件结构

使用 `BindWidget` 确保 UMG 中的组件必须存在：

```cpp
// 窗口边框
UPROPERTY(BlueprintReadOnly, meta = (BindWidget))
TObjectPtr<UBorder> WindowBorder;

// 标题栏
UPROPERTY(BlueprintReadOnly, meta = (BindWidget))
TObjectPtr<UGaiaDraggableTitleBar> TitleBar;

// 内容槽位（在Blueprint中添加内容）
UPROPERTY(BlueprintReadOnly, meta = (BindWidget))
TObjectPtr<UNamedSlot> ContentSlot;
```

**UMG 结构**：
```
Canvas Panel (根)
  └─ WindowBorder (Border) ⭐ 必须命名为 "WindowBorder"
      └─ Vertical Box
          ├─ TitleBar (GaiaDraggableTitleBar) ⭐ 必须命名为 "TitleBar"
          └─ ContentSlot (Named Slot) ⭐ 必须命名为 "ContentSlot"
```

### 4. 事件系统

```cpp
/** 窗口关闭事件 */
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnWindowClosed);
UPROPERTY(BlueprintAssignable, Category = "Window|Events")
FOnWindowClosed OnWindowClosed;

/** 窗口显示事件 */
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnWindowShown);
UPROPERTY(BlueprintAssignable, Category = "Window|Events")
FOnWindowShown OnWindowShown;
```

**使用示例**：
```cpp
// C++ 绑定事件
MyWindow->OnWindowClosed.AddDynamic(this, &AMyController::OnWindowClosed);

// Blueprint 绑定事件
// 在 Event Graph 中直接拖出 OnWindowClosed 节点
```

---

## 完整 API 列表

### 窗口控制

| 函数 | 说明 | Blueprint |
|------|------|-----------|
| `ShowWindow()` | 显示窗口（添加到视口并设置位置） | ✅ |
| `CloseWindow()` | 关闭窗口（从父级移除） | ✅ |

### 窗口属性

| 函数 | 说明 | Blueprint |
|------|------|-----------|
| `SetWindowTitle(FText)` | 设置窗口标题 | ✅ |
| `GetWindowTitle()` | 获取窗口标题 | ✅ |
| `SetWindowSize(FVector2D)` | 设置窗口大小 | ✅ |
| `GetWindowSize()` | 获取窗口大小 | ✅ |
| `SetWindowPosition(FVector2D)` | 设置窗口位置 | ✅ |
| `GetWindowPosition()` | 获取窗口位置 | ✅ |
| `CenterWindow()` | 居中显示窗口 | ✅ |
| `SetCloseButtonVisible(bool)` | 设置是否显示关闭按钮 | ✅ |
| `SetDraggable(bool)` | 设置是否可拖动 | ✅ |

### 可配置属性

| 属性 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `DefaultWindowTitle` | FText | "Window" | 默认窗口标题 |
| `DefaultWindowSize` | FVector2D | (800, 600) | 默认窗口大小 |
| `DefaultWindowPosition` | FVector2D | (-1, -1) | 默认窗口位置（-1表示居中） |
| `bAutoCenterOnShow` | bool | true | 是否在显示时自动居中 |
| `MinWindowSize` | FVector2D | (400, 300) | 最小窗口大小 |
| `MaxWindowSize` | FVector2D | (0, 0) | 最大窗口大小（0表示不限制） |
| `bShowCloseButton` | bool | true | 是否显示关闭按钮 |
| `WindowBorderColor` | FLinearColor | 金色 | 窗口边框颜色 |
| `WindowBorderThickness` | float | 2.0 | 窗口边框宽度 |
| `bSaveWindowPosition` | bool | false | 是否保存窗口位置 |
| `WindowPositionSaveKey` | FString | "" | 窗口位置保存Key |

---

## 使用流程

### 1. 创建 Widget Blueprint

```
Content Browser 右键
  → User Interface
  → Widget Blueprint
  → 父类选择 GaiaDraggableWindow
  → 命名为 WBP_MyWindow
```

### 2. 设计 UI 结构

在 UMG Designer 中添加必需的组件：

```
1. 添加 Border，命名为 "WindowBorder"
2. 在 Border 内添加 Vertical Box
3. 在 Vertical Box 中添加：
   - GaiaDraggableTitleBar，命名为 "TitleBar"
   - Named Slot，命名为 "ContentSlot"
4. 在 ContentSlot 中添加你的内容
```

### 3. 配置窗口属性

在 Details 面板中设置：
- Default Window Title = "我的窗口"
- Default Window Size = (1000, 700)
- Auto Center On Show = true

### 4. 显示窗口

**C++**：
```cpp
UGaiaDraggableWindow* Window = CreateWidget<UGaiaDraggableWindow>(GetWorld(), WindowClass);
Window->ShowWindow(); // 使用这个，不要用 AddToViewport()
```

**Blueprint**：
```
Create Widget (WBP_MyWindow)
  ↓
Show Window (调用此节点)
```

---

## 编译状态

✅ **编译成功**：

```
[3/4] Link [x64] GaiaGame.exe
[4/4] WriteMetadata GaiaGame.target
Result: Succeeded
Total execution time: 29.89 seconds
```

---

## 设计亮点

### 1. 彻底解决 AddToViewport 的满屏问题

通过正确使用：
- `SetAlignmentInViewport()`
- `SetDesiredSizeInViewport()`
- `SetPositionInViewport()`

完美控制窗口大小和位置。

### 2. 组件自动绑定

使用 `meta = (BindWidget)` 确保 UMG 组件结构正确：
```cpp
UPROPERTY(BlueprintReadOnly, meta = (BindWidget))
TObjectPtr<UBorder> WindowBorder;
```

如果 UMG 中缺少 `WindowBorder` 组件或名称错误，会在运行时报错。

### 3. 内容自定义

使用 `NamedSlot` 实现内容区域的完全自定义：
```cpp
UPROPERTY(BlueprintReadOnly, meta = (BindWidget))
TObjectPtr<UNamedSlot> ContentSlot;
```

在 Blueprint 的 UMG Designer 中，`ContentSlot` 可以包含任何子组件。

### 4. 继承架构

```
UCommonUserWidget (CommonUI)
  ↓
UGaiaDraggableWindow (窗口基类)
  ↓
UInventoryWindow, UCharacterWindow, etc. (具体窗口)
```

通过继承 `UCommonUserWidget`，未来可以利用 CommonUI 的特性（输入路由、激活栈等）。

### 5. 事件驱动设计

使用委托实现松耦合：
```cpp
// 定义事件
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnWindowClosed);
UPROPERTY(BlueprintAssignable)
FOnWindowClosed OnWindowClosed;

// 触发事件
OnWindowClosed.Broadcast();

// 绑定事件
Window->OnWindowClosed.AddDynamic(this, &MyClass::HandleWindowClosed);
```

### 6. 屏幕边界保护

通过 `GaiaDraggableTitleBar` 的边界限制，窗口永远不会被拖出屏幕：
```cpp
// 在 GaiaDraggableTitleBar.cpp 中
NewPosition.X = FMath::Clamp(NewPosition.X, 0.0f, ViewportSize.X - WidgetSize.X);
NewPosition.Y = FMath::Clamp(NewPosition.Y, 0.0f, ViewportSize.Y - WidgetSize.Y);
```

---

## 应用场景

### 1. 背包系统
```cpp
UInventoryWindow : public UGaiaDraggableWindow
{
    // 在 ContentSlot 中显示物品网格
};
```

### 2. 角色面板
```cpp
UCharacterWindow : public UGaiaDraggableWindow
{
    // 在 ContentSlot 中显示角色属性、装备槽等
};
```

### 3. 任务面板
```cpp
UQuestWindow : public UGaiaDraggableWindow
{
    // 在 ContentSlot 中显示任务列表
};
```

### 4. 设置面板
```cpp
USettingsWindow : public UGaiaDraggableWindow
{
    // 在 ContentSlot 中显示设置选项
};
```

### 5. 对话框
```cpp
UDialogWindow : public UGaiaDraggableWindow
{
    // 在 ContentSlot 中显示对话内容和选项按钮
};
```

---

## 后续扩展

### 可能的功能扩展

1. **窗口大小调整**
   - 在窗口边缘添加拖动区域
   - 实现 8 方向的大小调整

2. **窗口最小化/最大化**
   - 添加最小化按钮
   - 实现最小化到任务栏/Dock

3. **多窗口管理**
   - 实现窗口 Z-Order 管理
   - 点击窗口时自动置顶
   - 窗口焦点管理

4. **窗口动画**
   - 打开/关闭动画
   - 最小化/最大化动画
   - 使用 UMG Animation

5. **窗口位置保存**
   - 完善 `LoadWindowPosition()` 和 `SaveWindowPosition()`
   - 连接到 `GameUserSettings` 或存档系统
   - 支持多显示器

6. **窗口停靠**
   - 实现窗口停靠到屏幕边缘
   - 窗口磁性吸附

7. **窗口透明度**
   - 支持窗口透明度设置
   - 失焦时自动降低透明度

---

## 总结

### 已实现功能 ✅

- ✅ 完整的可拖拽窗口基类
- ✅ 解决 `AddToViewport` 满屏问题
- ✅ 自动大小和位置控制
- ✅ 居中显示支持
- ✅ 内容自定义（`NamedSlot`）
- ✅ 关闭按钮和事件
- ✅ 大小限制（最小/最大）
- ✅ 完全可配置的窗口样式
- ✅ 屏幕边界保护
- ✅ Blueprint 友好
- ✅ 事件驱动设计

### 核心价值

1. **开箱即用**：创建 Blueprint 继承即可使用
2. **解决痛点**：完美解决 `AddToViewport` 的满屏问题
3. **高度可配置**：所有属性都可在 Blueprint 中配置
4. **易于扩展**：通过继承可以快速创建各种窗口
5. **Blueprint 友好**：所有功能都暴露给 Blueprint

### 使用建议

1. **统一使用 `ShowWindow()`**：不要直接使用 `AddToViewport()`
2. **命名规范**：UMG 组件必须使用精确的名称（`WindowBorder`, `TitleBar`, `ContentSlot`）
3. **内容自定义**：所有具体内容都应放在 `ContentSlot` 中
4. **事件绑定**：使用 `OnWindowClosed` 和 `OnWindowShown` 事件管理窗口生命周期

---

## 文档

- ✅ `GaiaDraggableWindow.h` - 头文件（202行）
- ✅ `GaiaDraggableWindow.cpp` - 实现文件（311行）
- ✅ `GaiaDraggableWindow使用指南.md` - 完整使用指南
- ✅ `可拖拽窗口完成总结.md` - 本文档

---

现在你可以创建任意数量的可拖拽窗口，构建完整的窗口化 UI 系统！🎉

