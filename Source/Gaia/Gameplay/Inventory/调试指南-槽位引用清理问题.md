# 槽位引用清理问题 - 调试指南

## 🐛 **问题现象**

```
LogGaia: Error: [验证失败] 容器 7C148DE844C8C335B8EA198A4D6E6E5C 槽位 3 引用的物品 F2BA9E314C68C688B2F36D960F69698D 不存在！
LogGaia: Error: [验证失败] 容器 7C148DE844C8C335B8EA198A4D6E6E5C 槽位 5 引用的物品 B4E052C3413039D7E0F9F3B42834A9DE 不存在！
LogGaia: Error: 库存数据一致性验证失败！共发现 2 个错误
```

**说明**：
- 容器的槽位3和槽位5引用了不存在的物品
- 这意味着物品被删除时，槽位引用没有被正确清空

---

## 🔍 **已添加的调试日志**

### 1. 堆叠函数日志

在 `TryStackItems` 中添加了删除前的日志：

```cpp
// 行 1071-1078
UE_LOG(LogGaia, Warning, TEXT("【堆叠】源物品数量为0，准备删除: UID=%s, 容器=%s, 槽位=%d"), 
    *SourceItemUID.ToString(), 
    *SourceItemPtr->CurrentContainerUID.ToString(), 
    SourceItemPtr->CurrentSlotID);

DestroyItem(SourceItemUID);

UE_LOG(LogGaia, Warning, TEXT("【堆叠】源物品已删除: UID=%s"), *SourceItemUID.ToString());
```

### 2. 删除物品日志

在 `DestroyItem` 中添加了详细日志：

```cpp
UE_LOG(LogGaia, Warning, TEXT("【删除物品】开始: ItemUID=%s"), *ItemUID.ToString());
UE_LOG(LogGaia, Warning, TEXT("【删除物品】物品信息: 容器=%s, 槽位=%d, 数量=%d"), ...);
UE_LOG(LogGaia, Warning, TEXT("【删除物品】调用RemoveItemFromContainer..."));
UE_LOG(LogGaia, Warning, TEXT("【删除物品】RemoveItemFromContainer完成"));
UE_LOG(LogGaia, Warning, TEXT("【删除物品】完成: ItemUID=%s 已从AllItems中移除"), ...);
```

### 3. 移除物品日志

在 `RemoveItemFromContainer` 中添加了详细日志：

```cpp
UE_LOG(LogGaia, Warning, TEXT("【移除物品】开始: ItemUID=%s, 容器=%s, 槽位=%d"), ...);
UE_LOG(LogGaia, Warning, TEXT("【移除物品】清空槽位引用: 容器=%s, 槽位ID=%d, 槽位索引=%d, 原引用=%s"), ...);
UE_LOG(LogGaia, Warning, TEXT("【移除物品】槽位引用已清空"));
```

---

## 🚀 **下一步操作**

### 步骤1：重新编译

```bash
# 编译项目
Build GaiaEditor Win64 Development
```

### 步骤2：运行测试

```cpp
// 在蓝图或代码中
TestActor->RunMoveTest();
```

### 步骤3：查看日志输出

**打开 Output Log**，搜索关键字：
- `【堆叠】`
- `【删除物品】`
- `【移除物品】`

---

## 📊 **日志分析示例**

### 正常流程

```
LogGaia: Warning: 【堆叠】源物品数量为0，准备删除: UID=F2BA9E31..., 容器=7C148DE8..., 槽位=3
LogGaia: Warning: 【删除物品】开始: ItemUID=F2BA9E31...
LogGaia: Warning: 【删除物品】物品信息: 容器=7C148DE8..., 槽位=3, 数量=0
LogGaia: Warning: 【删除物品】调用RemoveItemFromContainer...
LogGaia: Warning: 【移除物品】开始: ItemUID=F2BA9E31..., 容器=7C148DE8..., 槽位=3
LogGaia: Warning: 【移除物品】清空槽位引用: 容器=7C148DE8..., 槽位ID=3, 槽位索引=2, 原引用=F2BA9E31...
LogGaia: Warning: 【移除物品】槽位引用已清空
LogGaia: Warning: 【删除物品】RemoveItemFromContainer完成
LogGaia: Warning: 【删除物品】完成: ItemUID=F2BA9E31... 已从AllItems中移除
```

### 异常流程（如果出现）

**可能情况1：槽位索引找不到**
```
LogGaia: Error: 【移除物品】无法找到槽位索引: SlotID=3
```
→ 说明槽位ID和槽位索引映射有问题

**可能情况2：物品位置信息错误**
```
LogGaia: Warning: 【删除物品】物品信息: 容器=7C148DE8..., 槽位=5, 数量=0
LogGaia: Warning: 【移除物品】清空槽位引用: 容器=7C148DE8..., 槽位ID=5, 槽位索引=4, 原引用=B4E052C3...
```
→ 如果实际物品在槽位3但CurrentSlotID是5，说明位置信息不同步

**可能情况3：容器不存在**
```
LogGaia: Error: 物品所在容器不存在: 7C148DE8...
```
→ 容器被提前删除

---

## 🔧 **可能的问题和解决方案**

### 问题1：部分移动时没有更新CurrentSlotID

**场景**：
- Item在Container的槽位3
- 部分移动到Container的槽位5（创建新Item）
- 但原Item的CurrentSlotID没有更新

**检查点**：
在 `MoveItemWithinContainer` 或 `MoveToEmptySlot` 中，部分移动时是否正确设置了新物品的CurrentSlotID。

**代码位置**：
```cpp
// MoveItemWithinContainer 行 1515-1531
if (bool bIsPartialMove = (Quantity < SourceItemPtr->Quantity))
{
    FGaiaItemInstance ItemToMove = *SourceItemPtr;
    ItemToMove.InstanceUID = FGuid::NewGuid();
    ItemToMove.Quantity = Quantity;
    ItemToMove.CurrentContainerUID = SourceItemPtr->CurrentContainerUID;
    ItemToMove.CurrentSlotID = TargetSlotID;  // ← 检查这里
    
    AllItems.Add(ItemToMove.InstanceUID, ItemToMove);
    TargetSlot.ItemInstanceUID = ItemToMove.InstanceUID;
    SourceItemPtr->Quantity -= Quantity;
    // ← 原物品的CurrentSlotID应该保持不变
}
```

---

### 问题2：AddItemToContainer的槽位分配

**场景**：
- 调用`AddItemToContainer`时，Item被添加到某个空槽位
- 但Item的`CurrentSlotID`没有被正确设置

**检查点**：
查看`AddItemToContainer`中是否正确更新了Item的CurrentSlotID。

**代码位置**：
```cpp
// AddItemToContainer
FGaiaItemInstance* ItemPtr = AllItems.Find(Item.InstanceUID);
if (ItemPtr)
{
    ItemPtr->CurrentContainerUID = ContainerUID;
    ItemPtr->CurrentSlotID = EmptySlot.SlotID;  // ← 检查这里
}
```

---

### 问题3：交换物品时的槽位引用

**场景**：
- 交换两个物品的位置
- 但槽位引用没有正确更新

**检查点**：
查看`SwapItems`函数。

---

## 📋 **日志检查清单**

运行测试后，按顺序检查以下日志：

### ✅ 测试1：移动到空槽位（跨容器部分移动）

**预期日志**：
- Item1创建
- Item1添加到Container1
- Item1部分移动到Container2
- 创建新Item（新GUID）

**检查点**：
- [ ] 新Item的GUID与原Item不同
- [ ] 原Item的CurrentSlotID保持不变
- [ ] 新Item的CurrentSlotID正确

---

### ✅ 测试2：堆叠相同物品

**预期日志**：
- Item2创建
- Item2添加到Container2（记录添加到哪个槽位）
- 堆叠：Item2移动到Container2槽位0
- `【堆叠】源物品数量为0，准备删除`
- `【删除物品】开始`
- `【移除物品】清空槽位引用`（记录清空的槽位）
- `【删除物品】完成`

**检查点**：
- [ ] Item2添加到的槽位 == 清空的槽位
- [ ] 槽位引用被正确清空

---

### ✅ 测试6：拆分移动

**预期日志**：
- Item6创建
- Item6添加到Container1（记录槽位）
- SplitItem：拆分8个到Container2
- 创建新Item

**检查点**：
- [ ] 原Item6数量减少，位置不变
- [ ] 新Item在Container2

---

## 🎯 **快速定位问题**

### 方法1：搜索失败的物品UID

在日志中搜索：
```
F2BA9E314C68C688B2F36D960F69698D
B4E052C3413039D7E0F9F3B42834A9DE
```

找到这两个物品：
- 何时创建
- 添加到哪个槽位
- 何时被删除
- 删除时清空了哪个槽位

### 方法2：搜索槽位3和槽位5

在日志中搜索：
```
槽位 3
槽位 5
槽位=3
槽位=5
```

找到：
- 哪些物品被添加到这两个槽位
- 哪些物品从这两个槽位移除
- 槽位引用何时被清空

---

## 💡 **临时解决方案（如果需要）**

如果问题难以定位，可以在测试前后添加完整的状态打印：

```cpp
// 在每个测试后添加
void PrintAllSlotReferences(UGaiaInventorySubsystem* InventorySystem)
{
    for (const auto& ContainerPair : InventorySystem->GetAllContainers())
    {
        const FGaiaContainerInstance& Container = ContainerPair.Value;
        UE_LOG(LogGaia, Warning, TEXT("容器 %s:"), *Container.ContainerUID.ToString());
        
        for (int32 i = 0; i < Container.Slots.Num(); i++)
        {
            const FGaiaSlotInfo& Slot = Container.Slots[i];
            if (!Slot.IsEmpty())
            {
                FGaiaItemInstance Item;
                bool bExists = InventorySystem->FindItemByUID(Slot.ItemInstanceUID, Item);
                UE_LOG(LogGaia, Warning, TEXT("  槽位%d (SlotID=%d): %s [%s]"), 
                    i, Slot.SlotID, *Slot.ItemInstanceUID.ToString(), 
                    bExists ? TEXT("存在") : TEXT("不存在!"));
            }
        }
    }
}
```

---

## ✅ **预期结果**

成功修复后，应该看到：

1. **所有物品删除时**：
   - 日志显示`【移除物品】清空槽位引用`
   - 槽位引用被设置为空GUID
   
2. **数据一致性验证**：
   - 所有槽位引用都指向存在的物品
   - 验证通过

3. **测试结果**：
   ```
   LogGaia: Log: [✓] 数据一致性验证 通过 - 所有移动操作后数据保持一致
   LogGaia: Log: === 移动物品测试完成 ===
   ```

---

**现在请编译并运行测试，查看详细日志！** 🚀

日志会告诉我们：
- 哪个物品在哪个槽位
- 何时被删除
- 槽位引用是否被清空
- 问题出在哪个环节

