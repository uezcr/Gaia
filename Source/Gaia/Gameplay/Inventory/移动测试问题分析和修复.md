# 移动测试数据一致性问题分析和修复

## 🐛 **问题描述**

在运行移动测试时，最后的数据一致性验证失败，报错：
```
[验证失败] 容器 XXX 槽位 X 引用的物品 XXX 不存在！
```

---

## 🔍 **问题分析**

### 原始测试代码

```cpp
// 测试2: 堆叠相同物品
FGaiaItemInstance Item2 = InventorySystem->CreateItemInstance(TEXT("TestItem"), 3);
InventorySystem->AddItemToContainer(Item2, Container2UID);

FMoveItemResult StackResult = InventorySystem->MoveItem(Item2.InstanceUID, Container2UID, 0, 3);

// 测试3: 部分堆叠
FGaiaItemInstance Item3 = InventorySystem->CreateItemInstance(TEXT("TestItem"), 20);
InventorySystem->AddItemToContainer(Item3, Container1UID);

FMoveItemResult PartialStackResult = InventorySystem->MoveItem(Item3.InstanceUID, Container2UID, 0, 20);
if (PartialStackResult.Result != EMoveItemResult::PartialSuccess)  // ← 问题所在
{
    LogTestResult(TEXT("部分堆叠"), false, ...);
    return false;
}
```

---

### 问题根源

**测试3的假设错误**：

测试3假设会返回 `PartialSuccess`（部分堆叠），但实际上这取决于物品的 `MaxStackSize` 设置。

**测试流程分析**：

1. **测试1**: Container2槽位0有5个TestItem
2. **测试2**: Container2槽位0堆叠后有8个TestItem
3. **测试3**: 
   - 尝试移动20个TestItem到槽位0
   - 如果 `MaxStackSize >= 28`（8+20），则会**完全堆叠**，返回 `Success`
   - 如果 `MaxStackSize < 28`，则会**部分堆叠**，返回 `PartialSuccess`

**问题**：

- 测试强制要求返回 `PartialSuccess`
- 但如果物品定义的 `MaxStackSize` 足够大（比如99），就会返回 `Success`
- 测试失败，返回 `false`，后续测试不执行
- **数据一致性验证没有运行，导致真正的问题被隐藏**

---

## 🛠️ **修复方案**

### 修改测试3：接受两种结果

```cpp
// 测试3: 堆叠测试（根据MaxStackSize可能是部分堆叠或完全堆叠）
FGaiaItemInstance Item3 = InventorySystem->CreateItemInstance(TEXT("TestItem"), 20);
InventorySystem->AddItemToContainer(Item3, Container1UID);

FMoveItemResult PartialStackResult = InventorySystem->MoveItem(Item3.InstanceUID, Container2UID, 0, 20);

// 根据实际情况判断结果
bool bIsPartialStack = (PartialStackResult.Result == EMoveItemResult::PartialSuccess);
bool bIsFullStack = (PartialStackResult.Result == EMoveItemResult::Success && PartialStackResult.MovedQuantity == 20);

if (!bIsPartialStack && !bIsFullStack)
{
    LogTestResult(TEXT("堆叠测试"), false, FString::Printf(TEXT("- 堆叠失败: %s"), *FormatMoveResult(PartialStackResult)));
    return false;
}

if (bIsPartialStack)
{
    LogTestResult(TEXT("部分堆叠"), true, FString::Printf(TEXT("- 部分堆叠成功: 移动=%d, 剩余=%d"), 
        PartialStackResult.MovedQuantity, PartialStackResult.RemainingQuantity));
}
else
{
    LogTestResult(TEXT("完全堆叠"), true, FString::Printf(TEXT("- 完全堆叠成功: 移动=%d 个物品"), 
        PartialStackResult.MovedQuantity));
}
```

**改进点**：

1. ✅ 接受两种合法结果：`PartialSuccess` 或 `Success`
2. ✅ 根据实际结果输出不同的日志
3. ✅ 只有在真正失败时才返回 `false`
4. ✅ 让测试继续执行，数据一致性验证能够运行

---

## 🎯 **验证修复**

### 修复后的测试流程

1. **测试1**: 跨容器部分移动 ✓
2. **测试2**: 完全堆叠 ✓
3. **测试3**: 堆叠测试（部分或完全） ✓ ← **修复**
4. **测试4**: 交换物品 ✓
5. **测试5**: 快速移动 ✓
6. **测试6**: 拆分移动 ✓
7. **测试7**: 容器内移动 ✓
8. **测试8**: 自动分配槽位 ✓
9. **数据一致性验证** ✓ ← **现在能执行到这里**

---

## 📊 **可能的其他问题**

虽然修复了测试3的假设错误，但如果数据一致性验证仍然失败，可能是以下原因：

### 潜在问题1：堆叠后槽位引用未清理

**场景**：
```
Item2 在 Container2 槽位1
Item2 堆叠到 Container2 槽位0
Item2 被 DestroyItem 删除
槽位1 的引用没有被清空？
```

**验证逻辑**：
```cpp
// TryStackItems 行1072
if (SourceItemPtr->Quantity <= 0)
{
    DestroyItem(SourceItemUID);  // 应该会调用 RemoveItemFromContainer
}

// DestroyItem 行477-480
if (Item->IsInContainer())
{
    RemoveItemFromContainer(ItemUID);  // 应该会清空槽位引用
}

// RemoveItemFromContainer 行429-434
int32 SlotIndex = Container->GetSlotIndexByID(Item->CurrentSlotID);
if (SlotIndex != INDEX_NONE)
{
    Container->Slots[SlotIndex].ItemInstanceUID = FGuid();  // 清空槽位
}
```

**理论上应该正确**，但需要实际运行验证。

---

### 潜在问题2：容器内移动的堆叠路径

**场景**：
```
测试2：Item2在Container2的某个槽位（假设槽位1）
       MoveItem(Item2, Container2, 槽位0, 3)
       → 检测到源容器==目标容器
       → 调用 MoveItemWithinContainer
       → 发现目标槽位0有物品
       → 调用 ProcessTargetSlotWithItem
       → 调用 TryStackItems
       → DestroyItem(Item2)
       → RemoveItemFromContainer 应该清空槽位1
```

**可能的问题**：
- 在`MoveItemWithinContainer`中，如果目标槽位有物品，会直接调用`ProcessTargetSlotWithItem`
- 但此时源物品的槽位引用还在
- 堆叠成功后，源物品被删除，`RemoveItemFromContainer`应该清空原槽位

**需要确认**：`Item2.CurrentSlotID`是否正确指向槽位1。

---

## ✅ **推荐的验证步骤**

### 步骤1：运行修复后的测试

```cpp
// 在蓝图或代码中
TestActor->RunMoveTest();
```

查看日志：
- 测试3是否通过
- 数据一致性验证是否通过

---

### 步骤2：如果数据一致性仍然失败

在 `ValidateDataIntegrity` 的错误日志中查找：
```
[验证失败] 容器 XXX 槽位 X 引用的物品 XXX 不存在！
```

记录：
- 容器UID
- 槽位ID
- 物品UID

---

### 步骤3：添加详细日志

在 `TryStackItems` 的 `DestroyItem` 调用前后添加日志：

```cpp
// 行1068-1073
if (SourceItemPtr->Quantity <= 0)
{
    UE_LOG(LogGaia, Warning, TEXT("【堆叠调试】准备删除源物品: %s, 当前容器: %s, 当前槽位: %d"), 
        *SourceItemUID.ToString(), 
        *SourceItemPtr->CurrentContainerUID.ToString(), 
        SourceItemPtr->CurrentSlotID);
    
    DestroyItem(SourceItemUID);
    
    UE_LOG(LogGaia, Warning, TEXT("【堆叠调试】源物品已删除: %s"), *SourceItemUID.ToString());
}
```

---

### 步骤4：检查容器状态

在每个测试后添加：

```cpp
// 打印所有槽位引用
for (const FGaiaSlotInfo& Slot : Container2->Slots)
{
    if (!Slot.IsEmpty())
    {
        UE_LOG(LogGaia, Log, TEXT("槽位%d: 引用物品 %s"), 
            Slot.SlotID, *Slot.ItemInstanceUID.ToString());
    }
}
```

---

## 🔧 **如果问题持续存在**

### 方案A：在堆叠前先清理源槽位

修改 `TryStackItems`，在堆叠前先从容器移除源物品：

```cpp
// 在更新数量之前
if (SourceItemPtr->IsInContainer())
{
    // 先从容器移除（但不删除物品）
    FGuid SourceContainerUID = SourceItemPtr->CurrentContainerUID;
    int32 SourceSlotID = SourceItemPtr->CurrentSlotID;
    
    // 手动清空槽位引用
    if (FGaiaContainerInstance* SourceContainer = Containers.Find(SourceContainerUID))
    {
        int32 SlotIndex = SourceContainer->GetSlotIndexByID(SourceSlotID);
        if (SlotIndex != INDEX_NONE)
        {
            SourceContainer->Slots[SlotIndex].ItemInstanceUID = FGuid();
        }
    }
    
    // 设置为游离状态
    SourceItemPtr->CurrentContainerUID = FGuid();
    SourceItemPtr->CurrentSlotID = -1;
}

// 然后更新数量和删除
SourceItemPtr->Quantity -= StackQuantity;
if (SourceItemPtr->Quantity <= 0)
{
    AllItems.Remove(SourceItemUID);  // 直接从AllItems删除，不调用DestroyItem
}
```

---

### 方案B：修改 DestroyItem 添加更多日志

```cpp
bool UGaiaInventorySubsystem::DestroyItem(const FGuid& ItemUID)
{
    UE_LOG(LogGaia, Warning, TEXT("【删除物品】开始: %s"), *ItemUID.ToString());
    
    FGaiaItemInstance* Item = AllItems.Find(ItemUID);
    if (!Item)
    {
        UE_LOG(LogGaia, Error, TEXT("【删除物品】失败: 物品不存在 - %s"), *ItemUID.ToString());
        return false;
    }
    
    UE_LOG(LogGaia, Warning, TEXT("【删除物品】物品信息: 容器=%s, 槽位=%d"), 
        *Item->CurrentContainerUID.ToString(), Item->CurrentSlotID);
    
    if (Item->IsInContainer())
    {
        UE_LOG(LogGaia, Warning, TEXT("【删除物品】从容器移除..."));
        RemoveItemFromContainer(ItemUID);
        UE_LOG(LogGaia, Warning, TEXT("【删除物品】从容器移除完成"));
    }
    
    AllItems.Remove(ItemUID);
    UE_LOG(LogGaia, Warning, TEXT("【删除物品】完成: %s"), *ItemUID.ToString());
    return true;
}
```

---

## 📝 **总结**

### 已修复
- ✅ 测试3的假设错误（强制要求PartialSuccess）
- ✅ 测试现在能执行到数据一致性验证

### 需要验证
- ⏳ 运行修复后的测试
- ⏳ 检查数据一致性验证是否通过

### 如果问题持续
- 📋 添加详细日志定位问题
- 🔧 根据日志输出调整解决方案

---

**建议立即运行测试查看结果！** 🚀

修复后的测试更加健壮，能够适应不同的物品定义配置，并且确保数据一致性验证能够执行。

