# Gaia 库存系统 - 设计说明

## 🎯 设计理念

**简洁、高效、可扩展** - 采用 BG3 风格的容器嵌套系统，适用于开放世界生存建造游戏。

## 📐 核心架构

### 系统组件

```
UGaiaInventorySubsystem (WorldSubsystem)
├── TMap<FGuid, FGaiaContainerInstance> Containers       // 所有容器实例
└── TMap<FGuid, FItemLocation> ItemLocationIndex         // 物品位置索引（O(1)查找）
```

### 数据结构

#### 定义层（DataRegistry）
```cpp
FGaiaItemDefinition          // 物品定义（名称、描述、重量、体积、堆叠等）
FGaiaContainerDefinition     // 容器定义（槽位数、体积限制、允许的标签等）
```

#### 实例层（运行时）
```cpp
FGaiaItemInstance           // 物品实例（UID、数量、所拥有的容器UID）
FGaiaContainerInstance      // 容器实例（UID、槽位、物品列表）
FGaiaSlotInfo              // 槽位信息（槽位ID、物品UID）
```

## 🔑 关键设计决策

### 1. UID 使用 FGuid

**选择：** 直接使用 `FGuid::NewGuid()`，不进行唯一性检查

**理由：**
- ✅ **碰撞概率极低**：2^128 种可能性，实际上不会发生
- ✅ **代码简洁**：无需维护 `UsedGuids` 集合
- ✅ **性能最优**：无任何检查开销
- ✅ **无内存浪费**：不需要额外的 `TSet<FGuid>`

**对比 `int32` 的优势：**
- `int32`：2^31 ≈ 21亿，长时间游戏可能耗尽
- `FGuid`：2^128 ≈ 3.4×10^38，实际上无限

### 2. 物品位置双索引系统

**问题：** 查找物品需要遍历所有容器（O(n*m)）

**解决方案：** 维护 `ItemLocationIndex`

```cpp
struct FItemLocation {
    FGuid ContainerUID;    // 物品所在的容器
    int32 ItemIndex;       // 物品在容器Items数组中的索引
};

TMap<FGuid, FItemLocation> ItemLocationIndex;  // O(1) 查找
```

**维护时机：**
- 添加物品时：`UpdateItemLocation()`
- 删除物品时：`RemoveItemLocation()` + `RebuildContainerItemIndices()`
- 移动物品时：`UpdateItemLocation()`

### 3. 容器嵌套设计

**物品 ↔ 容器的关系：**

```
FGaiaItemInstance {
    OwnedContainerUID    // 物品拥有的容器（如背包物品拥有背包容器）
}

FGaiaContainerInstance {
    OwnerItemUID         // 容器的拥有者物品
    ParentContainerUID   // 父容器（容器所在的容器）
    Items[]              // 容器内的物品
}
```

**嵌套规则：**
- 容器通过 `bAllowNestedContainers` 控制是否允许嵌套
- 物品体积必须小于容器内部体积
- 循环引用检测：向上遍历父容器链

### 4. 体积/重量计算

**递归计算：**
```cpp
GetItemTotalVolume(Item) {
    if (Item.HasContainer()) {
        return Max(ItemVolume, ItemVolume + ContainerUsedVolume);
    }
    return ItemVolume * Quantity;
}

GetItemTotalWeight(Item) {
    return ItemWeight * Quantity + ContainerUsedWeight;
}
```

**缓存机制：**
```cpp
FGaiaContainerInstance {
    mutable int32 CachedTotalVolume;
    mutable int32 CachedTotalWeight;
    mutable bool bNeedRecalculate;   // 添加/删除物品时标记
}
```

## 🎮 使用场景

### 场景 1: 玩家装备背包

```cpp
// 1. 创建背包物品（自动创建容器）
FGaiaItemInstance Backpack = CreateItemInstance("Backpack_Small");

// 2. 将背包添加到玩家装备槽
AddItemToContainer(Backpack, PlayerEquipmentContainerUID);

// 3. 向背包添加物品
AddItemToContainer(Apple, Backpack.OwnedContainerUID);
```

### 场景 2: 箱子套箱子

```cpp
// 1. 创建大箱子和小箱子
FGaiaItemInstance BigBox = CreateItemInstance("Box_Large");
FGaiaItemInstance SmallBox = CreateItemInstance("Box_Small");

// 2. 小箱子放入大箱子
AddItemToContainer(SmallBox, BigBox.OwnedContainerUID);

// 3. 物品放入小箱子
AddItemToContainer(Sword, SmallBox.OwnedContainerUID);

// 结构：BigBox -> SmallBox -> Sword
```

## 🔧 关键 API

### 创建
- `CreateItemInstance(ItemDefID, Quantity)` → `FGaiaItemInstance`
- `CreateContainer(ContainerDefID)` → `FGuid`

### 查询
- `FindItemByUID(ItemUID, OutItem)` → `bool`  // O(1)
- `FindContainerByUID(ContainerUID, OutContainer)` → `bool`

### 操作
- `AddItemToContainer(Item, ContainerUID)` → `bool`
- `RemoveItemFromContainer(ItemUID)` → `bool`
- `CanAddItemToContainer(Item, ContainerUID)` → `bool`

### 计算
- `GetItemTotalVolume(Item)` → `int32`
- `GetItemTotalWeight(Item)` → `int32`
- `GetContainerUsedVolume(ContainerUID)` → `int32`
- `GetContainerUsedWeight(ContainerUID)` → `int32`

## 📊 性能特性

| 操作 | 时间复杂度 | 说明 |
|------|-----------|------|
| 创建物品 | O(1) | 直接生成GUID + 初始化 |
| 创建容器 | O(n) | n = 槽位数 |
| 查找物品 | O(1) | 使用 ItemLocationIndex |
| 添加物品 | O(1) | 验证 + 添加 + 更新索引 |
| 删除物品 | O(m) | m = 删除位置后的物品数（需重建索引） |
| 计算体积/重量 | O(k) | k = 嵌套深度（递归） |

**内存占用估算：**
- 每个物品实例：~80 字节
- 每个容器实例：~200 字节 + 槽位数 × 24 字节
- 索引开销：每个物品 ~32 字节（GUID + Location）

**10,000 个物品：**
- 物品数据：~800 KB
- 索引数据：~320 KB
- **总计：~1.2 MB**

## ⚠️ 注意事项

### 1. GUID 不会冲突
- 理论碰撞概率：~1/(2^128) ≈ 0
- 实际使用无需担心

### 2. 索引维护
- 删除物品会触发索引重建（删除位置之后的物品）
- 批量删除建议从后往前删

### 3. 缓存失效
- 添加/删除物品时容器会标记 `bNeedRecalculate`
- 下次获取体积/重量时重新计算

### 4. 循环引用
- 系统会自动检测并阻止循环嵌套
- 使用 `TSet<FGuid>` 防止无限循环

## 🚀 后续扩展

### 计划中的功能
- [ ] 物品堆叠逻辑（自动合并相同物品）
- [ ] 容器排序功能
- [ ] 快速移动（整理、全部移动）
- [ ] 物品筛选（按标签、类型）
- [ ] 网络复制支持
- [ ] 存档/读档系统

### 扩展建议
- **堆叠系统**：在 `AddItemToContainer` 中先尝试堆叠
- **网络同步**：标记 `UPROPERTY(Replicated)` + RPC
- **UI绑定**：提供蓝图事件通知容器变化
- **持久化**：序列化 `Containers` 和 `ItemLocationIndex`

---

**文档版本:** 1.0  
**最后更新:** 2025-10-24  
**维护者:** Gaia 开发团队
