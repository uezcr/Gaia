# 网络测试计划

## 📋 **测试目标**

验证 `UGaiaInventoryRPCComponent` 在多人游戏中的正确性和稳定性。

---

## 🧪 **测试环境**

### PIE (Play In Editor) 多窗口测试

**设置步骤**：

1. 编辑 → 编辑器偏好设置 → Play
2. Multiplayer Options:
   - Number of Players: **2**
   - Play Mode: **Play As Listen Server**
   - Run Under One Process: **勾选**
3. 网络设置:
   - Use Single Process: **勾选**

---

## ✅ **测试用例**

### 阶段1：基础连接测试

#### 测试1.1：组件初始化
- **目标**: 验证 RPC Component 正确创建和复制
- **步骤**:
  1. 启动 PIE (2 players)
  2. 在服务器窗口，检查 PlayerController 是否有 RPC Component
  3. 在客户端窗口，检查 PlayerController 是否有 RPC Component
- **预期结果**:
  - ✅ 两个窗口都应该有组件实例
  - ✅ 服务器组件的 `GetOwnerRole()` 应该是 `ROLE_Authority`
  - ✅ 客户端组件的 `GetOwnerRole()` 应该是 `ROLE_SimulatedProxy` 或 `ROLE_AutonomousProxy`

#### 测试1.2：初始数据同步
- **目标**: 验证客户端能收到初始库存数据
- **步骤**:
  1. 服务器创建玩家背包容器
  2. 服务器添加几个测试物品
  3. 调用 `RequestRefreshInventory()`
- **预期结果**:
  - ✅ 客户端的 `CachedItems` 应该包含这些物品
  - ✅ 客户端的 `CachedContainers` 应该包含背包容器
  - ✅ 日志显示 `[网络] 客户端收到库存数据: X 个物品, Y 个容器`

---

### 阶段2：物品移动测试

#### 测试2.1：客户端请求移动物品
- **目标**: 验证客户端能通过RPC移动物品
- **步骤**:
  1. 客户端调用 `RequestMoveItem(ItemUID, TargetContainer, TargetSlot, Quantity)`
  2. 观察服务器日志
  3. 观察客户端是否收到更新
- **预期结果**:
  - ✅ 服务器执行 `ServerMoveItem_Implementation`
  - ✅ 服务器调用 `Subsystem->MoveItem()`
  - ✅ 客户端收到 `ClientReceiveInventoryData` 更新
  - ✅ 客户端触发 `OnInventoryUpdated` 事件

#### 测试2.2：服务器拒绝无效请求
- **目标**: 验证服务器权限检查
- **步骤**:
  1. 客户端请求移动不存在的物品
  2. 客户端请求移动属于其他玩家的物品（权限系统实现后）
- **预期结果**:
  - ✅ 服务器拒绝请求
  - ✅ 客户端收到 `ClientOperationFailed`
  - ✅ 客户端触发 `OnOperationFailed` 事件

---

### 阶段3：多玩家交互测试

#### 测试3.1：各自操作自己的背包
- **目标**: 验证两个玩家可以独立操作自己的库存
- **步骤**:
  1. 玩家1 移动物品 A
  2. 玩家2 移动物品 B
  3. 交替进行多次操作
- **预期结果**:
  - ✅ 玩家1 看不到玩家2 的物品
  - ✅ 玩家2 看不到玩家1 的物品
  - ✅ 各自操作互不干扰

#### 测试3.2：世界容器交互
- **目标**: 验证多个玩家可以访问同一个世界容器
- **步骤**:
  1. 服务器创建一个世界容器（箱子）
  2. 玩家1 打开箱子
  3. 玩家2 打开箱子
  4. 玩家1 从箱子中取物品
  5. 玩家2 应该看到物品消失
- **预期结果**:
  - ✅ 两个玩家都能看到箱子内容
  - ✅ 一个玩家的操作，另一个玩家能实时看到
  - ✅ 不会出现重复拿取或物品丢失

---

### 阶段4：压力测试

#### 测试4.1：大量物品同步
- **目标**: 验证网络性能
- **步骤**:
  1. 创建 100+ 个物品
  2. 执行多次移动操作
  3. 观察网络流量和延迟
- **预期结果**:
  - ✅ 客户端能正确接收所有数据
  - ✅ 网络流量在可接受范围内
  - ✅ 无明显卡顿

#### 测试4.2：快速连续操作
- **目标**: 验证RPC队列处理
- **步骤**:
  1. 客户端快速连续移动物品（例如快速拖拽）
  2. 观察是否有丢失或错乱
- **预期结果**:
  - ✅ 所有操作都被正确处理
  - ✅ 最终状态一致
  - ✅ 无崩溃或错误

---

### 阶段5：边界情况测试

#### 测试5.1：网络断线重连
- **目标**: 验证断线恢复
- **步骤**:
  1. 玩家正常游戏
  2. 模拟断线（关闭客户端）
  3. 重新连接
- **预期结果**:
  - ✅ 重连后自动请求刷新库存
  - ✅ 数据与服务器一致

#### 测试5.2：延迟环境
- **目标**: 验证高延迟下的行为
- **步骤**:
  1. 使用网络模拟工具增加延迟（例如 100ms+）
  2. 执行物品移动操作
- **预期结果**:
  - ✅ 操作最终成功
  - ✅ UI 有合理的反馈（loading 状态等）
  - ✅ 无数据不一致

---

## 🔧 **测试辅助工具**

### 调试控制台命令

创建一些调试命令来辅助测试：

```cpp
// 在 GaiaInventoryRPCComponent.cpp 中添加

#if !UE_BUILD_SHIPPING

static FAutoConsoleCommand CVarDebugPrintRPCState(
    TEXT("Gaia.Inventory.Network.PrintState"),
    TEXT("打印当前玩家的网络状态"),
    FConsoleCommandDelegate::CreateLambda([]()
    {
        if (UWorld* World = GEngine->GetWorldFromContextObject(GEngine->GameViewport, EGetWorldErrorMode::ReturnNull))
        {
            for (FConstPlayerControllerIterator It = World->GetPlayerControllerIterator(); It; ++It)
            {
                APlayerController* PC = It->Get();
                if (!PC) continue;

                UGaiaInventoryRPCComponent* RPCComp = PC->FindComponentByClass<UGaiaInventoryRPCComponent>();
                if (!RPCComp) continue;

                UE_LOG(LogGaia, Warning, TEXT("=== 玩家 %s ==="), *PC->GetName());
                UE_LOG(LogGaia, Warning, TEXT("Owner Role: %d"), RPCComp->GetOwnerRole());
                UE_LOG(LogGaia, Warning, TEXT("拥有的容器: %d"), RPCComp->OwnedContainerUIDs.Num());
                UE_LOG(LogGaia, Warning, TEXT("缓存的物品: %d"), RPCComp->CachedItems.Num());
                UE_LOG(LogGaia, Warning, TEXT("缓存的容器: %d"), RPCComp->CachedContainers.Num());
            }
        }
    })
);

static FAutoConsoleCommand CVarDebugForceRefresh(
    TEXT("Gaia.Inventory.Network.ForceRefresh"),
    TEXT("强制刷新当前玩家的库存数据"),
    FConsoleCommandDelegate::CreateLambda([]()
    {
        if (UWorld* World = GEngine->GetWorldFromContextObject(GEngine->GameViewport, EGetWorldErrorMode::ReturnNull))
        {
            if (APlayerController* PC = World->GetFirstPlayerController())
            {
                if (UGaiaInventoryRPCComponent* RPCComp = PC->FindComponentByClass<UGaiaInventoryRPCComponent>())
                {
                    RPCComp->RequestRefreshInventory();
                    UE_LOG(LogGaia, Log, TEXT("已请求刷新库存"));
                }
            }
        }
    })
);

#endif // !UE_BUILD_SHIPPING
```

### 测试 Actor

创建一个测试用的 Actor：

```cpp
// GaiaInventoryNetworkTestActor.h

UCLASS()
class AGaiaInventoryNetworkTestActor : public AActor
{
    GENERATED_BODY()

public:
    AGaiaInventoryNetworkTestActor();

    virtual void BeginPlay() override;

    /** 运行基础网络测试 */
    UFUNCTION(BlueprintCallable, Category = "Test")
    void RunNetworkTests();

private:
    void TestRPCBasic();
    void TestItemMove();
    void TestWorldContainer();
};
```

---

## 📊 **测试检查清单**

### 功能测试

- [ ] RPC Component 正确创建和复制
- [ ] 初始数据同步成功
- [ ] 客户端能请求移动物品
- [ ] 服务器正确验证权限
- [ ] 多玩家独立操作
- [ ] 世界容器多人访问
- [ ] 事件正确触发

### 性能测试

- [ ] 大量物品同步 (100+)
- [ ] 快速连续操作
- [ ] 网络流量合理
- [ ] 无明显卡顿

### 边界测试

- [ ] 断线重连恢复
- [ ] 高延迟环境
- [ ] 无效请求拒绝
- [ ] 数据一致性验证

### 安全测试

- [ ] 权限检查有效
- [ ] RPC Validate 正常工作
- [ ] 无法访问他人物品
- [ ] 无法操作超出范围的容器

---

## 🐛 **已知问题和待办**

### 当前 TODO

1. **权限系统** - 需要在 `UGaiaInventorySubsystem` 中实现：
   - `CanPlayerAccessItem()`
   - `CanPlayerAccessContainer()`
   - `IsPlayerInRangeOfContainer()`

2. **广播优化** - 需要实现精准广播：
   - 只广播给访问相关容器的玩家
   - 避免全服广播

3. **增量同步** - 可选优化：
   - 使用 `ClientReceiveInventoryDelta` 替代全量同步
   - 减少网络流量

4. **客户端预测** - 可选增强：
   - 本地预测操作结果
   - 服务器确认后更新或回滚
   - 提升用户体验

---

## 🎯 **下一步**

1. **编译代码** ✅ (无错误)
2. **创建测试关卡** 
3. **运行 PIE 测试**
4. **实现权限系统**
5. **优化网络性能**

---

**准备好开始测试了吗？** 🚀

