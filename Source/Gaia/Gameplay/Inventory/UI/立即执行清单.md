# 立即执行清单

> 基于CommonUI源码分析后的关键修复

---

## 🎯 核心问题

**RootViewportLayouts 为空的根本原因：**

Epic的CommonUI设计中，`LayoutClass` 是 `UGameUIPolicy` 的一个 **蓝图可编辑属性**（`UPROPERTY(EditAnywhere)`），而不是一个虚函数！

```cpp
// GameUIPolicy.h (Epic源码)
UCLASS(MinimalAPI, Abstract, Blueprintable, Within = GameUIManagerSubsystem)
class UGameUIPolicy : public UObject
{
private:
    UPROPERTY(EditAnywhere)  // ⭐ 蓝图属性，不是虚函数！
    TSoftClassPtr<UPrimaryGameLayout> LayoutClass;
    
    // 这只是读取上面的属性，不需要覆盖！
    TSubclassOf<UPrimaryGameLayout> GetLayoutWidgetClass(UCommonLocalPlayer* LocalPlayer);
};
```

**如果 `LayoutClass` 未设置：**
- `GetLayoutWidgetClass()` 返回 null
- `CreateLayoutWidget()` 中的 `ensure()` 失败
- 不会创建 `PrimaryGameLayout`
- `RootViewportLayouts` 保持为空

---

## ✅ 我已经修复的问题

### 1. 配置Section错误

```ini
# 修复前（错误）
[/Script/GaiaGame.GaiaUIManagerSubsystem]
DefaultUIPolicyClass=/Game/UI/BP_GaiaUIPolicy.BP_GaiaUIPolicy_C

# 修复后（正确）
[/Script/CommonGame.GameUIManagerSubsystem]  ⭐ 必须是父类的section
DefaultUIPolicyClass=/Game/UI/BP_GaiaUIPolicy.BP_GaiaUIPolicy_C
```

**原因：** `UGameUIManagerSubsystem::Initialize()` 读取配置时使用自己的类名，不是子类的类名。

### 2. 添加 ShouldCreateSubsystem 覆盖

```cpp
// GaiaUIManagerSubsystem.cpp
bool UGaiaUIManagerSubsystem::ShouldCreateSubsystem(UObject* Outer) const
{
    if (UGameInstance* GameInstance = Cast<UGameInstance>(Outer))
    {
        return !GameInstance->IsDedicatedServerInstance();
    }
    return false;
}
```

---

## ⚠️ 你现在必须做的事

### 步骤1：检查 GameMode 的 PlayerController 设置 ⭐⭐⭐⭐⭐

**这是最关键的一步！你说 PlayerController 为 null！**

1. 打开 `Content/Test/TestLevel`
2. 工具栏 → **Settings** → **World Settings**
3. **Game Mode Override** → 打开对应的 GameMode
4. **Player Controller Class** → 设置为 `PlayerController` 或 `GaiaPlayerController`
5. **编译并保存**

详见：`快速修复-PlayerController为null.md`

---

### 步骤2：重新编译C++ ⭐⭐⭐

我修改了 `GaiaUIPolicy.h/.cpp`、`GaiaUIManagerSubsystem.cpp` 和 `DefaultGame.ini`

1. 关闭UE编辑器
2. 在VS/Rider中编译项目
3. 重新打开UE编辑器

---

### 步骤3：配置 BP_GaiaUIPolicy ⭐⭐⭐⭐⭐

**这是最关键的一步！**

1. 打开 `Content/UI/BP_GaiaUIPolicy`

2. **Class Defaults** 或 **Details** 面板

3. 找到 **Layout Class** 属性
   - 可能在 "Game UI Policy" 分类下
   - 可能在 "Config" 分类下
   - 类型是 `TSoftClassPtr<UPrimaryGameLayout>`

4. 设置为：**WBP_GaiaPrimaryGameLayout**

5. **编译并保存** ⭐

---

### 步骤4：验证 WBP_GaiaPrimaryGameLayout

打开 `Content/UI/WBP_GaiaPrimaryGameLayout`

**确认Widget Hierarchy：**
```
Canvas Panel (Root)
├── GameLayer (CommonActivatableWidgetStack) ✅ Is Variable
├── ContainerLayer (CommonActivatableWidgetStack) ✅ Is Variable
├── MenuLayer (CommonActivatableWidgetStack) ✅ Is Variable
└── ModalLayer (CommonActivatableWidgetStack) ✅ Is Variable
```

**确认每个Stack都勾选了 "Is Variable"！**

---

### 步骤5：重启编辑器

配置修改后必须完全重启！

---

### 步骤6：测试并检查日志

运行PIE，查看输出日志：

#### ✅ 成功的日志应该是：

```
LogGaia: Log: [Gaia UI管理器] 初始化
LogGaia: Log: [Gaia UI管理器] ✅ UIPolicy已创建: BP_GaiaUIPolicy_C_0

LogCommonGame: Log: AddLocalPlayer: Set GaiaLocalPlayer_0 to Primary Player

LogGaia: Log: [UI Policy] CreateLayoutWidget 被调用: Player=GaiaLocalPlayer_0
LogGaia: Log: [UI Policy] ✅ PlayerController存在: PlayerController_0，继续创建Layout

LogCommonGame: Log: [BP_GaiaUIPolicy_C] is adding player [GaiaLocalPlayer_0]'s root layout [WBP_GaiaPrimaryGameLayout_C_0] to the viewport
LogGaia: Log: [UI Policy] ✅ 玩家布局已添加到Viewport: Player=GaiaLocalPlayer_0, Layout=WBP_GaiaPrimaryGameLayout_C_0
```

#### ❌ 如果看到 "PlayerController为null" 错误：

```
LogGaia: Error: [UI Policy] ❌ PlayerController为null！
```

**→ 返回步骤1，检查 GameMode 的 PlayerControllerClass 配置！**

详见：`快速修复-PlayerController为null.md`

#### ❌ 如果看到其他错误：

使用诊断工具（见 `UI诊断工具.md`），把完整的诊断日志发给我。

---

## 📖 关键知识点

### Epic的CommonUI设计哲学

#### 1. 配置属于父类，不是子类

```ini
# 父类的属性（DefaultUIPolicyClass）必须放在父类的section下
[/Script/CommonGame.GameUIManagerSubsystem]
DefaultUIPolicyClass=/Game/UI/BP_GaiaUIPolicy.BP_GaiaUIPolicy_C

# 子类自己的属性才放在子类的section下
[/Script/GaiaGame.GaiaUIManagerSubsystem]
ContainerWindowClass=/Game/UI/WBP_ContainerWindow.WBP_ContainerWindow_C
```

#### 2. 配置驱动 > 代码覆盖

- `LayoutClass` 是蓝图属性，在蓝图中设置
- 不是虚函数，不需要在C++中覆盖

#### 3. 完整的初始化链路

```
引擎启动
  ↓
创建 GameInstance
  ↓
UGameUIManagerSubsystem::Initialize()
  └── 读取 DefaultUIPolicyClass 配置
  └── 创建 UIPolicy 对象
  ↓
UCommonGameInstance::AddLocalPlayer()  ⭐ 必须是 CommonGameInstance
  ↓
UGameUIManagerSubsystem::NotifyPlayerAdded()
  ↓
UGameUIPolicy::NotifyPlayerAdded()
  ↓
UGameUIPolicy::CreateLayoutWidget()
  └── 调用 GetLayoutWidgetClass()
      └── 读取蓝图属性 LayoutClass  ⭐ 必须在BP中设置
  └── CreateWidget<UPrimaryGameLayout>()
  └── 添加到 RootViewportLayouts 数组
  └── AddToPlayerScreen()
```

**如果 `LayoutClass` 未设置 → RootViewportLayouts 为空！**

---

## 🔍 如何检查 LayoutClass 是否设置

### 方法1：在蓝图编辑器中检查

1. 打开 `BP_GaiaUIPolicy`
2. Window → Class Defaults（或点击工具栏的"Class Defaults"按钮）
3. 在Details面板中搜索 "Layout"
4. 查看 **Layout Class** 是否有值

### 方法2：查看 .uasset 文件（高级）

如果蓝图损坏或无法打开，可以尝试在文本编辑器中打开 `.uasset` 文件（二进制+文本混合格式），搜索 "LayoutClass"。

### 方法3：使用诊断代码

在C++中添加调试代码：

```cpp
void AYourActor::BeginPlay()
{
    Super::BeginPlay();
    
    UGameUIManagerSubsystem* UIManager = GetGameInstance()->GetSubsystem<UGameUIManagerSubsystem>();
    if (UIManager)
    {
        UGameUIPolicy* Policy = UIManager->GetCurrentUIPolicy();
        if (Policy)
        {
            // 尝试获取Layout
            UPrimaryGameLayout* Layout = UPrimaryGameLayout::GetPrimaryGameLayoutForPrimaryPlayer(this);
            if (!Layout)
            {
                UE_LOG(LogTemp, Error, TEXT("❌ Layout为null！检查BP_GaiaUIPolicy的LayoutClass是否设置！"));
            }
            else
            {
                UE_LOG(LogTemp, Log, TEXT("✅ Layout已创建: %s"), *Layout->GetClass()->GetName());
            }
        }
    }
}
```

---

## 📋 最终检查清单

- [ ] ✅ 已修复 `Config/DefaultGame.ini` 的section（我已完成）
- [ ] ✅ 已添加 `ShouldCreateSubsystem` 覆盖（我已完成）
- [ ] ⚠️ 已重新编译C++代码（你需要做）
- [ ] ⚠️ 已设置 `BP_GaiaUIPolicy` 的 `Layout Class` 属性（你需要做）
- [ ] ⚠️ 已验证 `WBP_GaiaPrimaryGameLayout` 的4个Layer Stacks（你需要做）
- [ ] ⚠️ 已重启编辑器（你需要做）
- [ ] ⚠️ 测试并查看日志（你需要做）

---

**重点：去 BP_GaiaUIPolicy 设置 Layout Class 属性！这是最可能的问题！**

