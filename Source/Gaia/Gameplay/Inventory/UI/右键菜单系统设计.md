# 右键菜单系统设计分析

## 一、需求分析

### 1.1 功能需求

根据之前的讨论，右键菜单需要：

1. **物品类型差异化**
   - 不同类型的物品有不同的菜单选项
   - 可配置的菜单项（通过枚举或表格）

2. **基础操作**
   - 使用（Use）
   - 丢弃（Drop）
   - 拆分（Split）- 如果可堆叠
   - 销毁（Destroy）
   - 查看详情（Inspect）

3. **容器物品特殊操作**
   - 打开容器（Open Container）
   - 清空容器（Empty Container）

4. **装备物品特殊操作**
   - 装备（Equip）
   - 卸下（Unequip）

### 1.2 交互需求

- 右键点击物品槽位触发菜单
- 菜单显示在鼠标位置附近
- 点击菜单外区域关闭菜单
- 选择菜单项执行对应操作
- 支持键盘快捷键（ESC关闭）

## 二、技术方案设计

### 2.1 架构设计

```
┌─────────────────────────────────────┐
│      UGaiaItemSlotWidget            │
│  (物品槽位，触发右键菜单)           │
└──────────────┬──────────────────────┘
               │ NativeOnMouseButtonDown
               │ (右键点击)
               ▼
┌─────────────────────────────────────┐
│   UGaiaItemContextMenu              │
│   (右键菜单Widget，显示操作列表)    │
│   - 继承自 UCommonActivatableWidget │
└──────────────┬──────────────────────┘
               │ 菜单项配置
               ▼
┌─────────────────────────────────────┐
│   FGaiaItemDefinition               │
│   (物品定义，包含菜单配置)          │
│   - ContextMenuType (枚举)          │
│   - CustomMenuActions (可选)        │
└─────────────────────────────────────┘
```

### 2.2 数据结构设计

#### 2.2.1 菜单类型枚举

```cpp
// 物品右键菜单类型
UENUM(BlueprintType)
enum class EItemContextMenuType : uint8
{
    None            UMETA(DisplayName = "无菜单"),
    Consumable      UMETA(DisplayName = "消耗品"),      // 使用、丢弃、销毁
    Equipment       UMETA(DisplayName = "装备"),        // 装备、丢弃、销毁
    Container       UMETA(DisplayName = "容器"),        // 打开、清空、丢弃
    Material        UMETA(DisplayName = "材料"),        // 拆分、丢弃、销毁
    QuestItem       UMETA(DisplayName = "任务物品"),    // 查看详情
    Custom          UMETA(DisplayName = "自定义")       // 使用自定义配置
};
```

#### 2.2.2 菜单操作枚举

```cpp
// 菜单操作类型
UENUM(BlueprintType)
enum class EItemContextAction : uint8
{
    Use             UMETA(DisplayName = "使用"),
    Equip           UMETA(DisplayName = "装备"),
    Unequip         UMETA(DisplayName = "卸下"),
    OpenContainer   UMETA(DisplayName = "打开容器"),
    EmptyContainer  UMETA(DisplayName = "清空容器"),
    Split           UMETA(DisplayName = "拆分"),
    Drop            UMETA(DisplayName = "丢弃"),
    Destroy         UMETA(DisplayName = "销毁"),
    Inspect         UMETA(DisplayName = "查看详情"),
    Custom          UMETA(DisplayName = "自定义")
};
```

#### 2.2.3 菜单配置结构

```cpp
// 单个菜单项配置
USTRUCT(BlueprintType)
struct FItemContextMenuItem
{
    GENERATED_BODY()

    /** 菜单操作类型 */
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    EItemContextAction Action;

    /** 显示文本（如果为空，使用默认文本） */
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    FText DisplayText;

    /** 图标（可选） */
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    TSoftObjectPtr<UTexture2D> Icon;

    /** 是否启用 */
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    bool bEnabled = true;

    /** 自定义事件名（当Action为Custom时使用） */
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    FName CustomEventName;
};
```

#### 2.2.4 扩展物品定义

```cpp
// 在 FGaiaItemDefinition 中添加：
struct FGaiaItemDefinition : public FTableRowBase
{
    // ... 现有字段 ...

    /** 右键菜单类型 */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "UI")
    EItemContextMenuType ContextMenuType = EItemContextMenuType::Material;

    /** 自定义菜单项（仅当ContextMenuType为Custom时使用） */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "UI")
    TArray<FItemContextMenuItem> CustomMenuItems;
};
```

### 2.3 Widget设计

#### 2.3.1 菜单Widget（UGaiaItemContextMenu）

**继承关系**：
```
UCommonActivatableWidget (CommonUI基类)
    └─ UGaiaItemContextMenu (右键菜单)
```

**主要功能**：
1. 显示菜单项列表
2. 处理点击事件
3. 自动定位到鼠标位置
4. 点击外部关闭
5. 动画效果（淡入淡出）

**UMG结构**：
```
Canvas Panel
└─ Border (菜单背景)
    └─ Vertical Box (菜单项容器)
        ├─ MenuItem Button 1
        ├─ MenuItem Button 2
        └─ MenuItem Button N
```

#### 2.3.2 菜单项Button（UGaiaContextMenuButton）

**继承关系**：
```
UCommonButtonBase (CommonUI按钮)
    └─ UGaiaContextMenuButton (菜单项按钮)
```

**UMG结构**：
```
Horizontal Box
├─ Image (图标，可选)
└─ Text Block (文本)
```

### 2.4 核心流程

#### 2.4.1 显示菜单流程

```
1. 玩家右键点击物品槽位
   └─ UGaiaItemSlotWidget::NativeOnMouseButtonDown
       └─ 检查是否为右键
           └─ 获取物品定义
               └─ 获取菜单配置
                   └─ 创建菜单Widget
                       └─ 添加到UI Layer (Menu Layer)
                           └─ 定位到鼠标位置
                               └─ 激活菜单
```

#### 2.4.2 执行操作流程

```
1. 玩家点击菜单项
   └─ UGaiaContextMenuButton::OnClicked
       └─ 获取操作类型
           ├─ 标准操作 (Use, Drop, etc.)
           │   └─ 调用对应的RPC函数
           │       └─ 关闭菜单
           │
           └─ 自定义操作
               └─ 广播自定义事件
                   └─ 关闭菜单
```

## 三、实现细节

### 3.1 关键类实现

#### 3.1.1 UGaiaItemContextMenu.h

```cpp
UCLASS()
class GAIA_API UGaiaItemContextMenu : public UCommonActivatableWidget
{
    GENERATED_BODY()

public:
    /** 初始化菜单 */
    UFUNCTION(BlueprintCallable, Category = "Gaia|UI")
    void InitializeMenu(const FGuid& InItemUID, const FGaiaItemDefinition& ItemDef);

    /** 设置菜单位置（屏幕坐标） */
    UFUNCTION(BlueprintCallable, Category = "Gaia|UI")
    void SetMenuPosition(FVector2D ScreenPosition);

protected:
    virtual void NativeConstruct() override;
    virtual void NativeOnActivated() override;
    virtual void NativeOnDeactivated() override;

    /** 构建菜单项 */
    void BuildMenuItems(const FGaiaItemDefinition& ItemDef);

    /** 获取预定义菜单项 */
    TArray<FItemContextMenuItem> GetPredefinedMenuItems(EItemContextMenuType MenuType) const;

    /** 处理菜单项点击 */
    UFUNCTION()
    void OnMenuItemClicked(EItemContextAction Action, FName CustomEventName);

    /** 关闭菜单 */
    UFUNCTION(BlueprintCallable, Category = "Gaia|UI")
    void CloseMenu();

protected:
    /** 当前物品UID */
    UPROPERTY(BlueprintReadOnly, Category = "Gaia|UI")
    FGuid CurrentItemUID;

    /** 菜单项容器（UMG绑定） */
    UPROPERTY(BlueprintReadOnly, meta = (BindWidget))
    UVerticalBox* MenuItemsContainer;

    /** 菜单项按钮类 */
    UPROPERTY(EditDefaultsOnly, Category = "Gaia|UI")
    TSubclassOf<UGaiaContextMenuButton> MenuItemButtonClass;

    /** 自定义操作事件 */
    UPROPERTY(BlueprintAssignable, Category = "Gaia|UI")
    FOnCustomMenuAction OnCustomAction;
};

DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnCustomMenuAction, FGuid, ItemUID, FName, ActionName);
```

#### 3.1.2 UGaiaContextMenuButton.h

```cpp
UCLASS()
class GAIA_API UGaiaContextMenuButton : public UCommonButtonBase
{
    GENERATED_BODY()

public:
    /** 设置菜单项数据 */
    UFUNCTION(BlueprintCallable, Category = "Gaia|UI")
    void SetMenuItemData(const FItemContextMenuItem& MenuItem);

    /** 获取操作类型 */
    EItemContextAction GetAction() const { return Action; }

    /** 获取自定义事件名 */
    FName GetCustomEventName() const { return CustomEventName; }

protected:
    virtual void NativePreConstruct() override;

protected:
    /** 操作类型 */
    UPROPERTY(BlueprintReadOnly, Category = "Gaia|UI")
    EItemContextAction Action;

    /** 自定义事件名 */
    UPROPERTY(BlueprintReadOnly, Category = "Gaia|UI")
    FName CustomEventName;

    /** 图标 */
    UPROPERTY(BlueprintReadOnly, meta = (BindWidget))
    UImage* Icon;

    /** 文本 */
    UPROPERTY(BlueprintReadOnly, meta = (BindWidget))
    UTextBlock* Text;
};
```

### 3.2 菜单预设配置

```cpp
TArray<FItemContextMenuItem> UGaiaItemContextMenu::GetPredefinedMenuItems(EItemContextMenuType MenuType) const
{
    TArray<FItemContextMenuItem> Items;

    switch (MenuType)
    {
    case EItemContextMenuType::Consumable:
        Items.Add({ EItemContextAction::Use, FText::FromString("使用"), nullptr, true });
        Items.Add({ EItemContextAction::Drop, FText::FromString("丢弃"), nullptr, true });
        Items.Add({ EItemContextAction::Destroy, FText::FromString("销毁"), nullptr, true });
        break;

    case EItemContextMenuType::Equipment:
        Items.Add({ EItemContextAction::Equip, FText::FromString("装备"), nullptr, true });
        Items.Add({ EItemContextAction::Drop, FText::FromString("丢弃"), nullptr, true });
        Items.Add({ EItemContextAction::Destroy, FText::FromString("销毁"), nullptr, true });
        break;

    case EItemContextMenuType::Container:
        Items.Add({ EItemContextAction::OpenContainer, FText::FromString("打开"), nullptr, true });
        Items.Add({ EItemContextAction::EmptyContainer, FText::FromString("清空"), nullptr, true });
        Items.Add({ EItemContextAction::Drop, FText::FromString("丢弃"), nullptr, true });
        break;

    case EItemContextMenuType::Material:
        Items.Add({ EItemContextAction::Split, FText::FromString("拆分"), nullptr, true });
        Items.Add({ EItemContextAction::Drop, FText::FromString("丢弃"), nullptr, true });
        Items.Add({ EItemContextAction::Destroy, FText::FromString("销毁"), nullptr, true });
        break;

    case EItemContextMenuType::QuestItem:
        Items.Add({ EItemContextAction::Inspect, FText::FromString("查看详情"), nullptr, true });
        break;

    default:
        break;
    }

    return Items;
}
```

### 3.3 ItemSlotWidget集成

```cpp
// 在 UGaiaItemSlotWidget 中添加：

FReply UGaiaItemSlotWidget::NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent)
{
    // 处理右键
    if (InMouseEvent.IsMouseButtonDown(EKeys::RightMouseButton) && !SlotInfo.IsEmpty())
    {
        ShowContextMenu(InMouseEvent.GetScreenSpacePosition());
        return FReply::Handled();
    }

    // 现有的左键逻辑...
    return Super::NativeOnMouseButtonDown(InGeometry, InMouseEvent);
}

void UGaiaItemSlotWidget::ShowContextMenu(FVector2D ScreenPosition)
{
    // 获取物品定义
    FGaiaItemDefinition ItemDef;
    if (!GetItemDefinition(ItemDef))
    {
        return;
    }

    // 创建菜单Widget
    if (!ContextMenuClass)
    {
        UE_LOG(LogGaia, Warning, TEXT("ContextMenuClass not set in ItemSlotWidget"));
        return;
    }

    UGaiaItemContextMenu* ContextMenu = CreateWidget<UGaiaItemContextMenu>(
        GetOwningPlayer(), ContextMenuClass);

    if (ContextMenu)
    {
        // 初始化菜单
        ContextMenu->InitializeMenu(SlotInfo.ItemInstanceUID, ItemDef);
        ContextMenu->SetMenuPosition(ScreenPosition);

        // 添加到UI Layer
        if (UGaiaUIManagerSubsystem* UIManager = UGaiaUIManagerSubsystem::Get(this))
        {
            UIManager->PushWidgetToLayer(
                FGameplayTag::RequestGameplayTag(TEXT("UI.Layer.Menu")),
                ContextMenu
            );
        }
    }
}
```

## 四、UI Layer管理

### 4.1 Layer配置

右键菜单应该显示在 **Menu Layer**，确保：
1. 在Container Layer之上
2. 可以被Modal Layer覆盖
3. 点击外部自动关闭

### 4.2 输入处理

```cpp
void UGaiaItemContextMenu::NativeOnActivated()
{
    Super::NativeOnActivated();

    // 设置输入模式（Game and UI）
    if (APlayerController* PC = GetOwningPlayer())
    {
        FInputModeGameAndUI InputMode;
        InputMode.SetWidgetToFocus(TakeWidget());
        InputMode.SetLockMouseToViewportBehavior(EMouseLockMode::DoNotLock);
        PC->SetInputMode(InputMode);
    }

    // 设置焦点
    SetFocus();
}
```

## 五、操作实现

### 5.1 标准操作

每个操作对应一个RPC调用或本地逻辑：

```cpp
void UGaiaItemContextMenu::OnMenuItemClicked(EItemContextAction Action, FName CustomEventName)
{
    UGaiaInventoryRPCComponent* RPCComp = GetRPCComponent();
    if (!RPCComp)
    {
        CloseMenu();
        return;
    }

    switch (Action)
    {
    case EItemContextAction::Use:
        // TODO: 实现使用物品逻辑
        break;

    case EItemContextAction::Drop:
        // TODO: 实现丢弃物品逻辑
        RPCComp->RequestDropItem(CurrentItemUID);
        break;

    case EItemContextAction::OpenContainer:
        // 打开容器
        if (UGaiaUIManagerSubsystem* UIManager = UGaiaUIManagerSubsystem::Get(this))
        {
            UIManager->OpenContainer(CurrentItemUID);
        }
        break;

    case EItemContextAction::Split:
        // 显示拆分对话框
        ShowSplitDialog();
        break;

    case EItemContextAction::Destroy:
        // 显示确认对话框
        ShowConfirmDialog();
        break;

    case EItemContextAction::Custom:
        // 广播自定义事件
        OnCustomAction.Broadcast(CurrentItemUID, CustomEventName);
        break;

    default:
        break;
    }

    CloseMenu();
}
```

### 5.2 扩展操作（未来）

- **使用物品**：触发物品效果（恢复生命、增加Buff等）
- **丢弃物品**：在世界中生成物品Actor
- **拆分物品**：显示数量输入对话框
- **销毁物品**：显示确认对话框

## 六、优先级和实施计划

### Phase 1: 基础框架（必须）
1. ✅ 枚举和数据结构定义
2. ✅ UGaiaItemContextMenu基础类
3. ✅ UGaiaContextMenuButton基础类
4. ✅ ItemSlotWidget集成右键事件
5. ✅ 预定义菜单配置

### Phase 2: 核心操作（重要）
1. ⏳ 打开容器操作
2. ⏳ 丢弃物品操作（需要世界Actor生成）
3. ⏳ 销毁物品操作（带确认对话框）

### Phase 3: 高级功能（可选）
1. ⏳ 使用物品系统（需要物品效果系统）
2. ⏳ 装备系统集成（需要装备槽位系统）
3. ⏳ 拆分对话框
4. ⏳ 自定义菜单项支持

## 七、技术要点

### 7.1 性能考虑

- **对象池**：复用菜单Widget，避免频繁创建销毁
- **延迟加载**：菜单项按需创建
- **快速关闭**：点击外部立即关闭，不等待动画

### 7.2 网络考虑

- **客户端预测**：菜单显示和关闭纯客户端
- **服务器验证**：所有操作通过RPC到服务器验证
- **权限检查**：服务器端验证玩家是否有权限执行操作

### 7.3 用户体验

- **智能定位**：菜单不超出屏幕边界
- **快捷键**：ESC关闭，数字键快速选择
- **视觉反馈**：Hover高亮，点击音效
- **动画**：淡入淡出，提升质感

## 八、测试计划

### 8.1 功能测试
- [ ] 右键点击显示菜单
- [ ] 菜单项根据物品类型正确显示
- [ ] 点击菜单项执行对应操作
- [ ] 点击外部关闭菜单
- [ ] ESC键关闭菜单

### 8.2 边界测试
- [ ] 屏幕边缘显示菜单（不超出屏幕）
- [ ] 空槽位右键无反应
- [ ] 快速连续右键不卡顿
- [ ] 网络延迟下操作正常

### 8.3 兼容性测试
- [ ] 单机模式正常
- [ ] PIE联机模式正常
- [ ] 不同分辨率下正常
- [ ] 手柄/键鼠切换正常

## 九、总结

右键菜单系统是库存UI的重要组成部分，设计时需要考虑：

1. **灵活性**：通过枚举和配置支持不同类型物品
2. **扩展性**：自定义菜单项支持
3. **易用性**：简洁的API，易于集成
4. **性能**：对象池、快速响应
5. **网络**：客户端显示，服务器验证

建议先实现 **Phase 1** 的基础框架和预定义菜单，然后根据实际需求逐步添加操作功能。

