# 右键菜单实施指南 - Phase 1 完成

## ✅ 已完成的工作

### 1. 数据结构定义
- ✅ `EItemContextMenuType` - 菜单类型枚举
- ✅ `EItemContextAction` - 操作类型枚举
- ✅ `FItemContextMenuItem` - 菜单项配置结构
- ✅ `FGaiaItemDefinition` - 添加了 `ContextMenuType` 和 `CustomMenuItems` 字段

### 2. Widget 类实现
- ✅ `UGaiaContextMenuButton` - 菜单项按钮Widget
- ✅ `UGaiaItemContextMenu` - 右键菜单Widget

### 3. 预定义菜单配置
- ✅ Consumable（消耗品）：使用、丢弃、销毁
- ✅ Equipment（装备）：装备、丢弃、销毁
- ✅ Container（容器）：打开、清空、丢弃
- ✅ Material（材料）：拆分、丢弃、销毁
- ✅ QuestItem（任务物品）：查看详情

## 📋 待完成的集成工作

### 步骤 1: 修改 GaiaUIManagerSubsystem

需要添加通过 ItemUID 打开容器的方法：

```cpp
// GaiaUIManagerSubsystem.h
public:
	/**
	 * 通过物品UID打开容器（右键菜单调用）
	 * @param ItemUID 物品UID
	 */
	UFUNCTION(BlueprintCallable, Category = "Gaia|UI")
	void OpenContainerByItemUID(const FGuid& ItemUID);

// GaiaUIManagerSubsystem.cpp
void UGaiaUIManagerSubsystem::OpenContainerByItemUID(const FGuid& ItemUID)
{
	// 1. 从库存子系统获取物品
	UGaiaInventorySubsystem* InvSys = UGaiaInventorySubsystem::Get(this);
	if (!InvSys)
	{
		return;
	}

	FGaiaItemInstance Item;
	if (!InvSys->FindItemByUID(ItemUID, Item))
	{
		UE_LOG(LogGaia, Warning, TEXT("OpenContainerByItemUID: Item not found"));
		return;
	}

	// 2. 检查物品是否有容器
	if (!Item.HasContainer())
	{
		UE_LOG(LogGaia, Warning, TEXT("OpenContainerByItemUID: Item has no container"));
		return;
	}

	// 3. 打开容器
	OpenContainer(Item.OwnedContainerUID);
}
```

### 步骤 2: 修改 GaiaItemSlotWidget

需要添加右键事件处理和菜单显示：

```cpp
// GaiaItemSlotWidget.h
protected:
	/** 右键菜单Widget类 */
	UPROPERTY(EditDefaultsOnly, Category = "Gaia|UI")
	TSubclassOf<UGaiaItemContextMenu> ContextMenuClass;

	/**
	 * 显示右键菜单
	 * @param ScreenPosition 屏幕位置
	 */
	void ShowContextMenu(FVector2D ScreenPosition);

	/**
	 * 获取物品定义
	 * @param OutItemDef 输出的物品定义
	 * @return 是否成功获取
	 */
	bool GetItemDefinition(FGaiaItemDefinition& OutItemDef) const;

// GaiaItemSlotWidget.cpp
FReply UGaiaItemSlotWidget::NativeOnMouseButtonDown(const FGeometry& InGeometry, const FPointerEvent& InMouseEvent)
{
	// 处理右键
	if (InMouseEvent.IsMouseButtonDown(EKeys::RightMouseButton) && !SlotInfo.IsEmpty())
	{
		ShowContextMenu(InMouseEvent.GetScreenSpacePosition());
		return FReply::Handled();
	}

	// 现有的左键逻辑...
	return Super::NativeOnMouseButtonDown(InGeometry, InMouseEvent);
}

void UGaiaItemSlotWidget::ShowContextMenu(FVector2D ScreenPosition)
{
	// 获取物品定义
	FGaiaItemDefinition ItemDef;
	if (!GetItemDefinition(ItemDef))
	{
		return;
	}

	// 检查菜单类型
	if (ItemDef.ContextMenuType == EItemContextMenuType::None)
	{
		return;
	}

	// 创建菜单Widget
	if (!ContextMenuClass)
	{
		UE_LOG(LogGaia, Warning, TEXT("ContextMenuClass not set in ItemSlotWidget"));
		return;
	}

	UGaiaItemContextMenu* ContextMenu = CreateWidget<UGaiaItemContextMenu>(
		GetOwningPlayer(), ContextMenuClass);

	if (ContextMenu)
	{
		// 初始化菜单
		ContextMenu->InitializeMenu(SlotInfo.ItemInstanceUID, ItemDef);
		ContextMenu->SetMenuPosition(ScreenPosition);

		// 添加到Menu Layer
		if (UGaiaUIManagerSubsystem* UIManager = UGaiaUIManagerSubsystem::Get(this))
		{
			UIManager->PushWidgetToLayer(
				FGameplayTag::RequestGameplayTag(TEXT("UI.Layer.Menu")),
				ContextMenu
			);
		}
	}
}

bool UGaiaItemSlotWidget::GetItemDefinition(FGaiaItemDefinition& OutItemDef) const
{
	if (SlotInfo.IsEmpty())
	{
		return false;
	}

	// 从库存子系统获取物品
	UGaiaInventorySubsystem* InvSys = UGaiaInventorySubsystem::Get(this);
	if (!InvSys)
	{
		return false;
	}

	FGaiaItemInstance Item;
	if (!InvSys->FindItemByUID(SlotInfo.ItemInstanceUID, Item))
	{
		return false;
	}

	// 获取物品定义
	return InvSys->GetItemDefinition(Item.ItemDefinitionID, OutItemDef);
}
```

### 步骤 3: 创建UMG蓝图

#### 3.1 创建菜单项按钮 (WBP_ContextMenuButton)

继承自 `UGaiaContextMenuButton`

**Widget结构**：
```
- Horizontal Box
  - Image: Icon (可见性: Collapsed)
  - Text Block: Text
```

**样式设置**：
- 背景：半透明黑色
- Hover：浅灰色高亮
- Padding：左右10，上下5
- 字体大小：14

#### 3.2 创建右键菜单 (WBP_ItemContextMenu)

继承自 `UGaiaItemContextMenu`

**Widget结构**：
```
- Canvas Panel
  - Border (MenuBackground)
    - Vertical Box: MenuItemsContainer (绑定)
```

**样式设置**：
- Border背景：深色半透明
- Border Padding：8
- 圆角：4
- 阴影：Offset(2,2), 模糊8

#### 3.3 配置 ItemSlotWidget (WBP_ItemSlot)

在 `WBP_ItemSlot` 的详情面板中：
1. 设置 `Context Menu Class` = `WBP_ItemContextMenu`

### 步骤 4: 配置测试物品

在 DataTable 中设置物品的 `ContextMenuType`：

| 物品 | ContextMenuType | 说明 |
|------|----------------|------|
| TestItem | Material | 普通材料 |
| TestItem2 | Consumable | 消耗品 |
| TestItem3 (带容器) | Container | 容器物品 |

## 🧪 测试步骤

### 1. 基础功能测试
1. ✅ 右键点击物品槽位显示菜单
2. ✅ 菜单项根据物品类型正确显示
3. ✅ 点击菜单项输出正确的日志
4. ✅ 点击菜单外关闭菜单
5. ✅ ESC键关闭菜单

### 2. 容器操作测试
1. ✅ 右键容器物品显示"打开"选项
2. ✅ 点击"打开"正确打开容器窗口
3. ✅ 多个容器可以同时打开

### 3. 边界测试
1. ✅ 空槽位右键无反应
2. ✅ 菜单不超出屏幕边界
3. ✅ 快速右键不卡顿

## 📝 注意事项

### 当前限制
1. **部分操作未实现**：
   - 使用物品（需要物品效果系统）
   - 装备系统（需要装备槽位）
   - 拆分对话框（Phase 3）
   - 确认对话框（Phase 3）
   - 丢弃物品（需要世界Actor生成）

2. **菜单定位**：
   - 当前版本菜单位置由UMG Canvas控制
   - 未实现智能避让屏幕边界
   - 建议在蓝图中实现定位逻辑

3. **输入处理**：
   - 使用 CommonUI 的 Layer 系统
   - ESC键关闭由 CommonActivatableWidget 自动处理
   - 点击外部关闭需要在UMG中配置

### 最佳实践
1. **在物品定义表中配置菜单类型**
2. **容器物品使用 Container 类型**
3. **可堆叠材料使用 Material 类型**
4. **任务物品使用 QuestItem 类型**
5. **特殊物品可以使用 Custom 自定义菜单**

## 🔜 下一步计划

### Phase 2: 核心操作实现
1. 实现"打开容器"操作（已完成框架）
2. 实现"丢弃物品"操作
3. 实现"销毁物品"操作（带确认）

### Phase 3: 高级功能
1. 拆分对话框
2. 使用物品系统
3. 装备系统集成
4. 自定义菜单项支持

## 📚 相关文档
- [右键菜单系统设计.md](右键菜单系统设计.md) - 完整设计文档
- [UI系统使用手册.md](UI系统使用手册.md) - UI系统总览

