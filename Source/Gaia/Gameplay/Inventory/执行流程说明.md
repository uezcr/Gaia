# Gaia 库存系统执行流程说明

本文档详细说明库存系统各项操作的完整执行流程，包括数据流转、函数调用顺序和关键检查点。

---

## 📋 **目录**

1. [系统初始化流程](#1-系统初始化流程)
2. [创建容器流程](#2-创建容器流程)
3. [创建物品流程](#3-创建物品流程)
4. [添加物品到容器流程](#4-添加物品到容器流程)
5. [物品移动流程](#5-物品移动流程)
6. [物品堆叠流程](#6-物品堆叠流程)
7. [物品交换流程](#7-物品交换流程)
8. [移除物品流程](#8-移除物品流程)
9. [删除物品流程](#9-删除物品流程)
10. [数据验证流程](#10-数据验证流程)

---

## 1. 系统初始化流程

### 执行时机
游戏世界加载时，`UGaiaInventorySubsystem` 作为 `UWorldSubsystem` 自动初始化。

### 执行步骤

```
1. 引擎调用 Initialize()
   ↓
2. 初始化数据结构
   - 清空 AllItems (TMap<FGuid, FGaiaItemInstance>)
   - 清空 Containers (TMap<FGuid, FGaiaContainerInstance>)
   ↓
3. 加载配置（UGaiaInventoryManagerSettings）
   - 从 DefaultEngine.ini 读取配置
   ↓
4. 输出初始化日志
   - UE_LOG: "库存子系统初始化完成"
   ↓
5. 系统就绪，等待调用
```

### 关键代码

```cpp
void UGaiaInventorySubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
    Super::Initialize(Collection);
    
    AllItems.Empty();
    Containers.Empty();
    
    UE_LOG(LogGaia, Log, TEXT("库存子系统初始化完成"));
}
```

### 数据状态

**初始化后**：
- `AllItems.Num()` = 0
- `Containers.Num()` = 0

---

## 2. 创建容器流程

### 函数调用
```cpp
FGuid ContainerUID = InventorySystem->CreateContainer(TEXT("PlayerBackpack"));
```

### 执行步骤

```
1. CreateContainer(ContainerDefID) 被调用
   ↓
2. 生成唯一容器UID
   - FGuid::NewGuid() → 生成全局唯一标识符
   ↓
3. 从 DataRegistry 查找容器定义
   - GetContainerDefinition(ContainerDefID, OutDef)
   ↓
4. 创建容器实例
   - FGaiaContainerInstance Container
   - Container.ContainerUID = 新生成的UID
   - Container.ContainerDefinitionID = 传入的DefID
   - Container.OwnerItemUID = 无效（顶层容器）
   - Container.ParentContainerUID = 无效（顶层容器）
   ↓
5. 根据定义初始化槽位
   - 循环 SlotCount 次
   - 创建 FGaiaSlotInfo，SlotID = i
   - Slots.Add(SlotInfo)
   ↓
6. 设置初始缓存值
   - CachedTotalWeight = 0
   - CachedTotalVolume = 0
   - bNeedRecalculate = true
   ↓
7. 添加到全局容器表
   - Containers.Add(ContainerUID, Container)
   ↓
8. 输出日志
   - UE_LOG: "创建容器: 名称, UID, 槽位数"
   ↓
9. 返回容器UID
```

### 数据流转

**输入**：
- `ContainerDefinitionID` (FName) - 容器类型ID

**输出**：
- `ContainerUID` (FGuid) - 新创建的容器唯一ID

**数据变化**：
- `Containers` 增加 1 个条目
- 新容器有 N 个空槽位（N = SlotCount）

### 示例

```cpp
// 创建玩家背包（20个槽位，500体积）
FGuid PlayerBackpackUID = InventorySystem->CreateContainer(TEXT("PlayerBackpack"));

// 结果：
// Containers[PlayerBackpackUID] = {
//     ContainerUID: PlayerBackpackUID,
//     ContainerDefinitionID: "PlayerBackpack",
//     Slots: [20个空槽位],
//     OwnerItemUID: 无效,
//     ParentContainerUID: 无效
// }
```

---

## 3. 创建物品流程

### 函数调用
```cpp
FGaiaItemInstance Item = InventorySystem->CreateItemInstance(TEXT("Wood"), 10);
```

### 执行步骤

```
1. CreateItemInstance(ItemDefID, Quantity) 被调用
   ↓
2. 生成唯一物品UID
   - FGuid::NewGuid() → 生成全局唯一标识符
   ↓
3. 从 DataRegistry 查找物品定义
   - GetItemDefinition(ItemDefID, OutDef)
   ↓
4. 创建物品实例
   - FGaiaItemInstance Item
   - Item.InstanceUID = 新生成的UID
   - Item.ItemDefinitionID = 传入的DefID
   - Item.Quantity = 传入的Quantity
   ↓
5. 检查物品是否有容器功能
   - if (ItemDef.ContainerDefinitionID 有效)
     ↓
     5.1. 调用 CreateContainer(ItemDef.ContainerDefinitionID)
     ↓
     5.2. 获取创建的容器UID
     ↓
     5.3. 设置容器的拥有者
         - Container.OwnerItemUID = Item.InstanceUID
     ↓
     5.4. 设置物品的拥有容器
         - Item.OwnedContainerUID = ContainerUID
   ↓
6. 设置物品位置为游离状态
   - Item.CurrentContainerUID = 无效
   - Item.CurrentSlotID = -1
   ↓
7. 添加到全局物品表
   - AllItems.Add(Item.InstanceUID, Item)
   ↓
8. 输出日志
   - UE_LOG: "创建物品: 名称, UID, 数量"
   - 如果有容器: "物品拥有容器: 容器UID"
   ↓
9. 返回物品实例（副本）
```

### 数据流转

**输入**：
- `ItemDefinitionID` (FName) - 物品类型ID
- `Quantity` (int32) - 数量

**输出**：
- `FGaiaItemInstance` - 新创建的物品实例

**数据变化**：
- `AllItems` 增加 1 个条目
- 如果物品有容器：`Containers` 也增加 1 个条目

### 示例场景

#### 场景1：创建普通物品（木头）

```cpp
FGaiaItemInstance Wood = InventorySystem->CreateItemInstance(TEXT("Wood"), 10);

// 结果：
// AllItems[Wood.InstanceUID] = {
//     InstanceUID: [新GUID],
//     ItemDefinitionID: "Wood",
//     Quantity: 10,
//     CurrentContainerUID: 无效 (游离状态),
//     CurrentSlotID: -1,
//     OwnedContainerUID: 无效 (没有容器)
// }
```

#### 场景2：创建背包物品（带容器）

```cpp
FGaiaItemInstance Backpack = InventorySystem->CreateItemInstance(TEXT("Backpack_Small"), 1);

// 结果：
// AllItems[Backpack.InstanceUID] = {
//     InstanceUID: [新GUID-A],
//     ItemDefinitionID: "Backpack_Small",
//     Quantity: 1,
//     CurrentContainerUID: 无效 (游离状态),
//     CurrentSlotID: -1,
//     OwnedContainerUID: [新GUID-B] (拥有容器)
// }
// 
// Containers[新GUID-B] = {
//     ContainerUID: [新GUID-B],
//     ContainerDefinitionID: "Container_Backpack_Small",
//     Slots: [10个空槽位],
//     OwnerItemUID: [新GUID-A] (属于背包物品),
//     ParentContainerUID: 无效
// }
```

---

## 4. 添加物品到容器流程

### 函数调用
```cpp
bool bSuccess = InventorySystem->AddItemToContainer(Item, ContainerUID);
```

### 执行步骤

```
1. AddItemToContainer(Item, ContainerUID) 被调用
   ↓
2. 验证输入参数
   - if (!Item.InstanceUID.IsValid()) → 返回 false
   - if (!ContainerUID.IsValid()) → 返回 false
   ↓
3. 查找目标容器
   - Container = Containers.Find(ContainerUID)
   - if (!Container) → 输出警告，返回 false
   ↓
4. 从 DataRegistry 获取容器定义
   - GetContainerDefinition(Container.ContainerDefinitionID, ContainerDef)
   ↓
5. 检查物品是否已在容器中
   - if (Item.IsInContainer())
     → 输出警告 "物品已在容器中"
     → 返回 false
   ↓
6. 【循环检测】如果物品有容器，检查是否会造成循环引用
   - if (Item.HasContainer())
     ↓
     6.1. 调用 WouldCreateCycle(Item.OwnedContainerUID, ContainerUID)
     ↓
     6.2. 向上遍历目标容器的父容器链
          - 如果找到与 Item.OwnedContainerUID 相同的容器
          → 返回 true（会造成循环）
     ↓
     6.3. if (会造成循环)
          → 输出警告 "会造成容器循环引用"
          → 返回 false
   ↓
7. 【体积检查】如果容器启用了体积限制
   - if (ContainerDef.bEnableVolumeLimit)
     ↓
     7.1. 获取容器当前已使用体积
          - UsedVolume = GetContainerUsedVolume(ContainerUID)
     ↓
     7.2. 获取物品总体积（递归计算）
          - ItemVolume = GetItemTotalVolume(Item)
     ↓
     7.3. 检查空间是否足够
          - if (UsedVolume + ItemVolume > ContainerDef.MaxVolume)
            → 输出警告 "容器体积不足"
            → 返回 false
   ↓
8. 查找空槽位
   - EmptySlotID = Container->FindEmptySlotID()
   - if (EmptySlotID == INDEX_NONE)
     → 输出警告 "容器已满"
     → 返回 false
   ↓
9. 将物品添加到 AllItems（如果还不在）
   - if (!AllItems.Contains(Item.InstanceUID))
     → AllItems.Add(Item.InstanceUID, Item)
   ↓
10. 更新物品位置信息
    - Item->CurrentContainerUID = ContainerUID
    - Item->CurrentSlotID = EmptySlotID
    ↓
11. 更新槽位引用
    - SlotIndex = Container->GetSlotIndexByID(EmptySlotID)
    - Container->Slots[SlotIndex].ItemInstanceUID = Item.InstanceUID
    ↓
12. 【嵌套处理】如果物品有容器，设置容器的父容器
    - if (Item.HasContainer())
      ↓
      12.1. ItemContainer = Containers.Find(Item.OwnedContainerUID)
      ↓
      12.2. ItemContainer->ParentContainerUID = ContainerUID
      ↓
      12.3. 输出日志 "设置物品容器的父容器"
    ↓
13. 标记容器需要重新计算缓存
    - Container->MarkDirty()
    ↓
14. 输出日志
    - UE_LOG: "成功添加物品到容器: 物品名称, 容器名称, 槽位ID"
    ↓
15. 返回 true
```

### 数据流转

**输入**：
- `Item` (FGaiaItemInstance) - 要添加的物品
- `ContainerUID` (FGuid) - 目标容器UID

**输出**：
- `bool` - 是否成功添加

**数据变化**：
- `AllItems[Item.InstanceUID]`：
  - `CurrentContainerUID` 从无效 → ContainerUID
  - `CurrentSlotID` 从 -1 → 具体槽位ID
- `Containers[ContainerUID].Slots[i]`：
  - `ItemInstanceUID` 从无效 → Item.InstanceUID
- 如果物品有容器：
  - `Containers[Item.OwnedContainerUID].ParentContainerUID` 从无效 → ContainerUID

### 失败情况

| 失败原因 | 检查点 | 返回值 | 日志 |
|---------|-------|-------|------|
| 参数无效 | 步骤2 | false | Warning: 物品或容器UID无效 |
| 容器不存在 | 步骤3 | false | Warning: 无法找到目标容器 |
| 物品已在容器中 | 步骤5 | false | Warning: 物品已在容器中 |
| 循环引用 | 步骤6 | false | Warning: 会造成容器循环引用 |
| 体积不足 | 步骤7 | false | Warning: 容器体积不足 |
| 容器已满 | 步骤8 | false | Warning: 容器已满 |

### 示例场景

#### 场景1：添加木头到玩家背包

```cpp
// 前提条件
FGaiaItemInstance Wood;  // UID=A, Quantity=10, 游离状态
FGuid BackpackUID;       // 玩家背包, 有15个空槽位

// 执行
bool bSuccess = InventorySystem->AddItemToContainer(Wood, BackpackUID);

// 结果：bSuccess = true
// AllItems[A].CurrentContainerUID = BackpackUID
// AllItems[A].CurrentSlotID = 0 (第一个空槽位)
// Containers[BackpackUID].Slots[0].ItemInstanceUID = A
```

#### 场景2：添加子背包到主背包（嵌套）

```cpp
// 前提条件
FGaiaItemInstance SubBackpack;  // UID=B, 有容器 (UID=C)
FGuid MainBackpackUID;          // UID=D

// 执行
bool bSuccess = InventorySystem->AddItemToContainer(SubBackpack, MainBackpackUID);

// 结果：bSuccess = true
// AllItems[B].CurrentContainerUID = D
// AllItems[B].CurrentSlotID = 0
// Containers[D].Slots[0].ItemInstanceUID = B
// Containers[C].ParentContainerUID = D  ← 建立嵌套关系
```

#### 场景3：循环引用被阻止

```cpp
// 前提条件
// MainBackpack(D) 包含 SubBackpack(B)
// SubBackpack(B) 拥有容器(C)

// 尝试将 MainBackpack 放入 SubBackpack 的容器
bool bSuccess = InventorySystem->AddItemToContainer(MainBackpack, C);

// 结果：bSuccess = false
// 原因：WouldCreateCycle 检测到 C → D → C 的循环
// 日志：Warning: 会造成容器循环引用
```

---

## 5. 物品移动流程

### 函数调用
```cpp
FMoveItemResult Result = InventorySystem->MoveItem(ItemUID, TargetContainerUID, TargetSlotID, Quantity);
```

### 执行步骤

```
1. MoveItem(ItemUID, TargetContainerUID, TargetSlotID, Quantity) 被调用
   ↓
2. 查找源物品
   - FindItemByUID(ItemUID, SourceItem)
   - if (!找到) → 返回 Failed
   ↓
3. 查找目标容器
   - Containers.Find(TargetContainerUID)
   - if (!找到) → 返回 InvalidTarget
   ↓
4. 设置默认移动数量
   - if (Quantity <= 0) → Quantity = SourceItem.Quantity
   ↓
5. 验证移动数量
   - if (Quantity > SourceItem.Quantity) → 返回 Failed
   ↓
6. 检查源物品是否在容器中
   - if (!SourceItem.IsInContainer()) → 返回 Failed
   ↓
7. 【分支判断】判断移动类型
   
   分支A：容器内移动（源容器 == 目标容器）
   ↓
   → 调用 MoveItemWithinContainer(ItemUID, TargetSlotID, Quantity)
   → 返回结果
   
   分支B：跨容器移动（源容器 != 目标容器）
   ↓
   继续执行步骤8
   ↓
8. 【跨容器移动】检查目标槽位
   
   情况1：指定了目标槽位 (TargetSlotID >= 0)
   ↓
   8.1. 验证槽位有效性
        - if (槽位不存在) → 返回 InvalidTarget
   ↓
   8.2. 检查目标槽位状态
        
        8.2.1 槽位为空
        ↓
        → 调用 MoveToEmptySlot(ItemUID, TargetContainerUID, TargetSlotID, Quantity)
        → 返回结果
        
        8.2.2 槽位有物品
        ↓
        → 获取目标槽位的物品
        → 调用 ProcessTargetSlotWithItem(ItemUID, TargetItem, TargetContainerUID, TargetSlotID, Quantity)
        → 返回结果
   
   情况2：未指定目标槽位 (TargetSlotID < 0)
   ↓
   → 调用 MoveItemAutoSlot(ItemUID, TargetContainerUID, Quantity)
   → 返回结果
```

### 子流程：MoveItemWithinContainer（容器内移动）

```
1. 获取源物品
   - SourceItem = AllItems.Find(ItemUID)
   ↓
2. 检查物品是否在容器中
   - if (!IsInContainer()) → 返回 Failed
   ↓
3. 获取容器
   - Container = Containers.Find(SourceItem->CurrentContainerUID)
   ↓
4. 验证目标槽位
   - if (TargetSlotID < 0) → 返回 InvalidTarget
   - if (槽位不存在) → 返回 InvalidTarget
   ↓
5. 获取目标槽位
   - TargetSlot = Container->Slots[TargetSlotIndex]
   ↓
6. 【分支判断】目标槽位状态
   
   分支A：目标槽位为空
   ↓
   6.A.1. 判断是否为部分移动
          - bIsPartialMove = (Quantity < SourceItem->Quantity)
   ↓
   6.A.2. 如果是部分移动
          ↓
          a) 创建新物品实例
             - NewItem = *SourceItem
             - NewItem.InstanceUID = FGuid::NewGuid()  ← 生成新GUID
             - NewItem.Quantity = Quantity
             - NewItem.CurrentSlotID = TargetSlotID
          ↓
          b) 添加新物品到 AllItems
             - AllItems.Add(NewItem.InstanceUID, NewItem)
          ↓
          c) 更新目标槽位引用
             - TargetSlot.ItemInstanceUID = NewItem.InstanceUID
          ↓
          d) 减少源物品数量
             - SourceItem->Quantity -= Quantity
          ↓
          → 返回 Success
   
   6.A.3. 如果是完全移动
          ↓
          a) 清空原槽位引用
             - OldSlot.ItemInstanceUID = 无效
          ↓
          b) 更新物品槽位ID
             - SourceItem->CurrentSlotID = TargetSlotID
          ↓
          c) 更新新槽位引用
             - TargetSlot.ItemInstanceUID = ItemUID
          ↓
          → 返回 Success
   
   分支B：目标槽位有物品
   ↓
   → 调用 ProcessTargetSlotWithItem(...)
   → 返回结果
```

### 子流程：MoveToEmptySlot（移动到空槽位）

```
1. 获取源物品
   - FindItemByUID(ItemUID, SourceItem)
   ↓
2. 设置移动数量
   - if (Quantity <= 0) → Quantity = SourceItem.Quantity
   ↓
3. 判断是否为部分移动
   - bIsPartialMove = (Quantity < SourceItem.Quantity)
   ↓
4. 创建要移动的物品实例
   - ItemToMove = SourceItem
   - ItemToMove.Quantity = Quantity
   ↓
5. 如果是部分移动，生成新UID
   - if (bIsPartialMove)
     → ItemToMove.InstanceUID = FGuid::NewGuid()
   ↓
6. 检查是否可以添加到目标容器
   - CanAddItemToContainer(ItemToMove, TargetContainerUID)
   - if (!可以) → 返回 Failed
   ↓
7. 添加到目标容器
   - AddItemToContainer(ItemToMove, TargetContainerUID)
   ↓
8. 更新源物品
   - SourceItem->Quantity -= Quantity
   ↓
9. 如果源物品数量为0，删除源物品
   - if (SourceItem->Quantity <= 0)
     → DestroyItem(ItemUID)
   ↓
10. 返回 Success
```

### 子流程：ProcessTargetSlotWithItem（目标槽位有物品）

```
1. 获取源物品
   - FindItemByUID(ItemUID, SourceItem)
   ↓
2. 【分支判断】源物品和目标物品的类型
   
   分支A：类型相同（可堆叠）
   ↓
   → 调用 TryStackItems(ItemUID, TargetItem.InstanceUID, Quantity)
   → 返回结果
   
   分支B：目标物品有容器
   ↓
   3. 尝试放入目标物品的容器
      - Result = TryMoveToContainer(ItemUID, TargetItem.InstanceUID, Quantity)
   ↓
   4. 如果放入成功
      → 返回 Success
   ↓
   5. 如果放入失败
      → 返回 ContainerRejected（不交换）
   
   分支C：类型不同且目标物品无容器
   ↓
   6. 尝试交换位置
      - if (CanSwapItems(ItemUID, TargetItem.InstanceUID))
        → 调用 SwapItems(ItemUID, TargetItem.InstanceUID)
        → 返回 SwapPerformed
      - else
        → 返回 Failed
```

### 数据流转

**输入**：
- `ItemUID` (FGuid) - 要移动的物品UID
- `TargetContainerUID` (FGuid) - 目标容器UID
- `TargetSlotID` (int32) - 目标槽位ID（-1表示自动分配）
- `Quantity` (int32) - 移动数量（<= 0表示全部）

**输出**：
- `FMoveItemResult` - 移动结果
  - `Result` (EMoveItemResult) - 成功/失败原因
  - `MovedQuantity` (int32) - 实际移动的数量
  - `RemainingQuantity` (int32) - 剩余未移动的数量
  - `TargetContainerUID` (FGuid) - 实际目标容器UID
  - `ErrorMessage` (FString) - 错误信息

**数据变化**（成功时）：
- `AllItems[ItemUID]`：
  - `CurrentContainerUID` 可能改变
  - `CurrentSlotID` 改变
  - `Quantity` 可能减少
- `Containers[SourceContainerUID].Slots[OldSlot]`：
  - `ItemInstanceUID` 被清空或不变
- `Containers[TargetContainerUID].Slots[NewSlot]`：
  - `ItemInstanceUID` 被设置

### 移动结果类型

| 结果 | 说明 | MovedQuantity | RemainingQuantity |
|------|------|---------------|-------------------|
| **Success** | 完全成功移动 | = Quantity | 0 |
| **PartialSuccess** | 部分移动（堆叠已满） | < Quantity | > 0 |
| **SwapPerformed** | 执行了交换 | = Quantity | 0 |
| **Failed** | 移动失败 | 0 | = Quantity |
| **InvalidTarget** | 目标无效 | 0 | = Quantity |
| **ContainerFull** | 容器已满 | 0 | = Quantity |
| **ContainerRejected** | 容器拒绝 | 0 | = Quantity |

### 示例场景

#### 场景1：容器内移动（完全移动）

```cpp
// 前提条件
// Wood(UID=A) 在 Backpack(UID=B) 的槽位0，数量=10
// 槽位5为空

// 执行
FMoveItemResult Result = InventorySystem->MoveItem(A, B, 5, 10);

// 结果：Result.Result = Success
// AllItems[A].CurrentSlotID: 0 → 5
// Containers[B].Slots[0].ItemInstanceUID: A → 无效
// Containers[B].Slots[5].ItemInstanceUID: 无效 → A
```

#### 场景2：容器内移动（部分移动）

```cpp
// 前提条件
// Wood(UID=A) 在槽位0，数量=10
// 槽位5为空

// 执行
FMoveItemResult Result = InventorySystem->MoveItem(A, B, 5, 3);

// 结果：Result.Result = Success
// 创建新物品实例 Wood(UID=C)，数量=3
// AllItems[A].Quantity: 10 → 7 (在槽位0)
// AllItems[C] = 新物品，数量=3 (在槽位5)
// Containers[B].Slots[5].ItemInstanceUID: 无效 → C
```

#### 场景3：跨容器移动

```cpp
// 前提条件
// Wood(UID=A) 在 Backpack1(UID=B)，槽位0，数量=10
// Backpack2(UID=D) 槽位3为空

// 执行
FMoveItemResult Result = InventorySystem->MoveItem(A, D, 3, 10);

// 结果：Result.Result = Success
// AllItems[A].CurrentContainerUID: B → D
// AllItems[A].CurrentSlotID: 0 → 3
// Containers[B].Slots[0].ItemInstanceUID: A → 无效
// Containers[D].Slots[3].ItemInstanceUID: 无效 → A
```

---

## 6. 物品堆叠流程

### 函数调用
```cpp
FMoveItemResult Result = InventorySystem->TryStackItems(SourceItemUID, TargetItemUID, Quantity);
```

### 执行步骤

```
1. TryStackItems(SourceItemUID, TargetItemUID, Quantity) 被调用
   ↓
2. 查找源物品和目标物品
   - FindItemByUID(SourceItemUID, SourceItem)
   - FindItemByUID(TargetItemUID, TargetItem)
   - if (任一未找到) → 返回 Failed
   ↓
3. 检查物品类型是否相同
   - if (SourceItem.ItemDefinitionID != TargetItem.ItemDefinitionID)
     → 返回 TypeMismatch
   ↓
4. 获取物品定义
   - GetItemDefinition(SourceItem.ItemDefinitionID, ItemDef)
   ↓
5. 检查是否可堆叠
   - if (ItemDef.MaxStackSize <= 1)
     → 返回 NotStackable
   ↓
6. 计算目标堆叠可容纳的数量
   - AvailableSpace = ItemDef.MaxStackSize - TargetItem.Quantity
   - if (AvailableSpace <= 0)
     → 返回 TargetFull
   ↓
7. 计算实际堆叠数量
   - StackQuantity = Min(Quantity, AvailableSpace)
   ↓
8. 获取目标物品指针（从 AllItems）
   - TargetItemPtr = AllItems.Find(TargetItemUID)
   ↓
9. 增加目标物品数量
   - TargetItemPtr->Quantity += StackQuantity
   ↓
10. 获取源物品指针（从 AllItems）
    - SourceItemPtr = AllItems.Find(SourceItemUID)
    ↓
11. 减少源物品数量
    - SourceItemPtr->Quantity -= StackQuantity
    ↓
12. 如果源物品数量为0，删除源物品
    - if (SourceItemPtr->Quantity <= 0)
      → DestroyItem(SourceItemUID)
    ↓
13. 标记相关容器需要重新计算
    - if (SourceItem在容器中)
      → SourceContainer->MarkDirty()
    - if (TargetItem在容器中)
      → TargetContainer->MarkDirty()
    ↓
14. 设置返回结果
    - if (StackQuantity == Quantity)
      → Result = Success（完全堆叠）
    - else
      → Result = PartialSuccess（部分堆叠）
    ↓
15. 返回结果
```

### 数据流转

**输入**：
- `SourceItemUID` (FGuid) - 源物品UID
- `TargetItemUID` (FGuid) - 目标物品UID
- `Quantity` (int32) - 要堆叠的数量

**输出**：
- `FMoveItemResult`
  - `MovedQuantity` - 实际堆叠的数量
  - `RemainingQuantity` - 剩余未堆叠的数量

**数据变化**：
- `AllItems[SourceItemUID].Quantity` 减少
- `AllItems[TargetItemUID].Quantity` 增加
- 如果源物品数量变为0：
  - `AllItems` 移除该条目
  - 相关槽位引用被清空

### 堆叠结果

| 场景 | 源数量 | 目标数量 | 最大堆叠 | 尝试堆叠 | 实际堆叠 | 结果 | 源剩余 | 目标最终 |
|------|--------|---------|---------|---------|---------|------|--------|----------|
| 完全堆叠 | 10 | 80 | 99 | 10 | 10 | Success | 0 (删除) | 90 |
| 部分堆叠 | 20 | 90 | 99 | 20 | 9 | PartialSuccess | 11 | 99 |
| 目标已满 | 10 | 99 | 99 | 10 | 0 | TargetFull | 10 | 99 |

### 示例场景

#### 场景1：完全堆叠

```cpp
// 前提条件
// Wood_A: 数量=10
// Wood_B: 数量=80 (最大堆叠99)

// 执行
FMoveItemResult Result = InventorySystem->TryStackItems(Wood_A, Wood_B, 10);

// 结果：Result.Result = Success
// Wood_A: 被删除（数量降为0）
// Wood_B: 数量 80 → 90
// MovedQuantity = 10, RemainingQuantity = 0
```

#### 场景2：部分堆叠

```cpp
// 前提条件
// Wood_A: 数量=20
// Wood_B: 数量=90 (最大堆叠99)

// 执行
FMoveItemResult Result = InventorySystem->TryStackItems(Wood_A, Wood_B, 20);

// 结果：Result.Result = PartialSuccess
// Wood_A: 数量 20 → 11
// Wood_B: 数量 90 → 99 (已满)
// MovedQuantity = 9, RemainingQuantity = 11
```

---

## 7. 物品交换流程

### 函数调用
```cpp
FMoveItemResult Result = InventorySystem->SwapItems(ItemUID1, ItemUID2);
```

### 执行步骤

```
1. SwapItems(ItemUID1, ItemUID2) 被调用
   ↓
2. 查找两个物品
   - FindItemByUID(ItemUID1, Item1)
   - FindItemByUID(ItemUID2, Item2)
   - if (任一未找到) → 返回 InvalidTarget
   ↓
3. 检查是否可以交换
   - if (!CanSwapItems(ItemUID1, ItemUID2))
     → 返回 Failed
   ↓
4. 从 AllItems 获取物品指针
   - ItemPtr1 = AllItems.Find(ItemUID1)
   - ItemPtr2 = AllItems.Find(ItemUID2)
   ↓
5. 保存原始位置信息
   - Container1UID = ItemPtr1->CurrentContainerUID
   - Slot1ID = ItemPtr1->CurrentSlotID
   - Container2UID = ItemPtr2->CurrentContainerUID
   - Slot2ID = ItemPtr2->CurrentSlotID
   ↓
6. 获取两个容器
   - Container1 = Containers.Find(Container1UID)
   - Container2 = Containers.Find(Container2UID)
   ↓
7. 交换物品的位置信息
   - ItemPtr1->CurrentContainerUID = Container2UID
   - ItemPtr1->CurrentSlotID = Slot2ID
   - ItemPtr2->CurrentContainerUID = Container1UID
   - ItemPtr2->CurrentSlotID = Slot1ID
   ↓
8. 交换槽位引用
   - SlotIndex1 = Container1->GetSlotIndexByID(Slot1ID)
   - SlotIndex2 = Container2->GetSlotIndexByID(Slot2ID)
   - Container1->Slots[SlotIndex1].ItemInstanceUID = ItemUID2
   - Container2->Slots[SlotIndex2].ItemInstanceUID = ItemUID1
   ↓
9. 标记容器需要重新计算
   - Container1->MarkDirty()
   - Container2->MarkDirty()
   ↓
10. 设置返回结果
    - Result.Result = SwapPerformed
    - Result.MovedQuantity = Item1.Quantity
    - Result.bWasSwapped = true
    ↓
11. 返回结果
```

### CanSwapItems 检查流程

```
1. 从 AllItems 获取两个物品
   - Item1 = AllItems.Find(ItemUID1)
   - Item2 = AllItems.Find(ItemUID2)
   - if (任一不存在) → 返回 false
   ↓
2. 检查两个物品是否都在容器中
   - if (!Item1->IsInContainer() || !Item2->IsInContainer())
     → 返回 false
   ↓
3. 检查物品1是否可以添加到物品2的容器
   - if (!CanAddItemToContainer(*Item1, Item2->CurrentContainerUID))
     → 返回 false
   ↓
4. 检查物品2是否可以添加到物品1的容器
   - if (!CanAddItemToContainer(*Item2, Item1->CurrentContainerUID))
     → 返回 false
   ↓
5. 返回 true（可以交换）
```

### 数据流转

**输入**：
- `ItemUID1` (FGuid) - 物品1的UID
- `ItemUID2` (FGuid) - 物品2的UID

**输出**：
- `FMoveItemResult`
  - `Result` = SwapPerformed（成功）
  - `bWasSwapped` = true

**数据变化**：
- `AllItems[ItemUID1]`：
  - `CurrentContainerUID` 与 ItemUID2 交换
  - `CurrentSlotID` 与 ItemUID2 交换
- `AllItems[ItemUID2]`：
  - `CurrentContainerUID` 与 ItemUID1 交换
  - `CurrentSlotID` 与 ItemUID1 交换
- `Container1.Slots[Slot1].ItemInstanceUID`: ItemUID1 → ItemUID2
- `Container2.Slots[Slot2].ItemInstanceUID`: ItemUID2 → ItemUID1

### 示例场景

#### 场景1：同一容器内交换

```cpp
// 前提条件
// Wood(UID=A) 在 Backpack(UID=C) 槽位0
// Stone(UID=B) 在 Backpack(UID=C) 槽位5

// 执行
FMoveItemResult Result = InventorySystem->SwapItems(A, B);

// 结果：Result.Result = SwapPerformed
// AllItems[A].CurrentSlotID: 0 → 5
// AllItems[B].CurrentSlotID: 5 → 0
// Containers[C].Slots[0].ItemInstanceUID: A → B
// Containers[C].Slots[5].ItemInstanceUID: B → A
```

#### 场景2：跨容器交换

```cpp
// 前提条件
// Wood(UID=A) 在 Backpack1(UID=C) 槽位0
// Stone(UID=B) 在 Backpack2(UID=D) 槽位3

// 执行
FMoveItemResult Result = InventorySystem->SwapItems(A, B);

// 结果：Result.Result = SwapPerformed
// AllItems[A]: Backpack1槽位0 → Backpack2槽位3
// AllItems[B]: Backpack2槽位3 → Backpack1槽位0
// Containers[C].Slots[0]: A → B
// Containers[D].Slots[3]: B → A
```

---

## 8. 移除物品流程

### 函数调用
```cpp
bool bSuccess = InventorySystem->RemoveItemFromContainer(ItemUID);
```

### 执行步骤

```
1. RemoveItemFromContainer(ItemUID) 被调用
   ↓
2. 验证参数
   - if (!ItemUID.IsValid()) → 返回 false
   ↓
3. 从 AllItems 获取物品
   - Item = AllItems.Find(ItemUID)
   - if (!找到) → 输出警告，返回 false
   ↓
4. 检查物品是否在容器中
   - if (!Item->IsInContainer())
     → 输出警告 "物品不在任何容器中"
     → 返回 false
   ↓
5. 获取物品所在容器
   - Container = Containers.Find(Item->CurrentContainerUID)
   - if (!找到) → 输出错误，返回 false
   ↓
6. 清空槽位引用
   - SlotIndex = Container->GetSlotIndexByID(Item->CurrentSlotID)
   - if (SlotIndex != INDEX_NONE)
     → Container->Slots[SlotIndex].ItemInstanceUID = 无效
   ↓
7. 如果物品有容器，清空容器的父容器引用
   - if (Item->HasContainer())
     ↓
     7.1. ItemContainer = Containers.Find(Item->OwnedContainerUID)
     ↓
     7.2. if (ItemContainer存在)
          → ItemContainer->ParentContainerUID = 无效
          → 输出日志 "清空物品容器的父容器引用"
   ↓
8. 将物品设为游离状态
   - OldContainerUID = Item->CurrentContainerUID
   - OldSlotID = Item->CurrentSlotID
   - Item->CurrentContainerUID = 无效
   - Item->CurrentSlotID = -1
   ↓
9. 标记容器需要重新计算
   - Container->MarkDirty()
   ↓
10. 输出日志
    - "从容器移除物品: ItemUID (容器: OldContainerUID, 槽位: OldSlotID) -> 游离状态"
    ↓
11. 返回 true
```

### 数据流转

**输入**：
- `ItemUID` (FGuid) - 要移除的物品UID

**输出**：
- `bool` - 是否成功移除

**数据变化**：
- `AllItems[ItemUID]`：
  - `CurrentContainerUID` 变为无效（游离状态）
  - `CurrentSlotID` 变为 -1
  - **物品仍存在于 AllItems 中**
- `Container.Slots[i].ItemInstanceUID` 被清空
- 如果物品有容器：
  - `ItemContainer.ParentContainerUID` 被清空

### 重要说明

**RemoveItemFromContainer vs DestroyItem**：

| 操作 | AllItems | Containers | 槽位引用 | 物品状态 | 用途 |
|------|---------|-----------|---------|---------|------|
| **RemoveItemFromContainer** | 保留 | 保留 | 清空 | 游离 | 掉落物品、卸下装备 |
| **DestroyItem** | 删除 | 删除（如有） | 清空 | 不存在 | 彻底删除物品 |

### 示例场景

#### 场景1：移除物品到游离状态

```cpp
// 前提条件
// Wood(UID=A) 在 Backpack(UID=B) 槽位0，数量=10

// 执行
bool bSuccess = InventorySystem->RemoveItemFromContainer(A);

// 结果：bSuccess = true
// AllItems[A] 仍存在，但状态改变：
//   CurrentContainerUID: B → 无效
//   CurrentSlotID: 0 → -1
//   IsOrphan() = true
// Containers[B].Slots[0].ItemInstanceUID: A → 无效

// 物品现在是游离状态，可以：
// - 作为掉落物显示在世界中
// - 装备到角色身上
// - 放入交易界面
```

#### 场景2：移除带容器的物品

```cpp
// 前提条件
// SubBackpack(UID=A) 在 MainBackpack(UID=B)
// SubBackpack 拥有容器(UID=C)
// 容器C 的 ParentContainerUID = B

// 执行
bool bSuccess = InventorySystem->RemoveItemFromContainer(A);

// 结果：bSuccess = true
// AllItems[A]: 游离状态
// Containers[B].Slots[i]: 清空
// Containers[C].ParentContainerUID: B → 无效  ← 解除嵌套关系
```

---

## 9. 删除物品流程

### 函数调用
```cpp
bool bSuccess = InventorySystem->DestroyItem(ItemUID);
```

### 执行步骤

```
1. DestroyItem(ItemUID) 被调用
   ↓
2. 验证参数
   - if (!ItemUID.IsValid()) → 返回 false
   ↓
3. 从 AllItems 获取物品
   - Item = AllItems.Find(ItemUID)
   - if (!找到) → 输出警告，返回 false
   ↓
4. 如果物品在容器中，先从容器移除
   - if (Item->IsInContainer())
     → RemoveItemFromContainer(ItemUID)
   ↓
5. 【递归删除】如果物品有容器
   - if (Item->HasContainer())
     ↓
     5.1. 获取容器内的所有物品
          - ItemsInContainer = GetItemsInContainer(Item->OwnedContainerUID)
     ↓
     5.2. 递归删除容器内的所有物品
          - for each (ContainedItem in ItemsInContainer)
            → DestroyItem(ContainedItem.InstanceUID)  ← 递归调用
     ↓
     5.3. 删除容器本身
          - Containers.Remove(Item->OwnedContainerUID)
          - 输出日志 "删除物品的容器: ContainerUID"
   ↓
6. 从 AllItems 删除物品
   - AllItems.Remove(ItemUID)
   ↓
7. 输出日志
   - "完全删除物品: ItemUID"
   ↓
8. 返回 true
```

### 递归删除示例

```
假设有如下嵌套结构：
MainBackpack (容器D)
  └─ SubBackpack1 (物品A, 容器C)
       ├─ Wood (物品E)
       └─ SubBackpack2 (物品B, 容器F)
            └─ Stone (物品G)

调用 DestroyItem(A) 的执行顺序：

1. DestroyItem(A) 开始
   ↓
2. 从容器D移除物品A
   ↓
3. 检测到A有容器C
   ↓
4. 获取容器C中的物品：[E, B]
   ↓
5. 递归删除物品E
   ├─ DestroyItem(E)
   ├─ E没有容器
   └─ 从AllItems删除E
   ↓
6. 递归删除物品B
   ├─ DestroyItem(B)
   ├─ 检测到B有容器F
   ├─ 获取容器F中的物品：[G]
   ├─ 递归删除物品G
   │  ├─ DestroyItem(G)
   │  ├─ G没有容器
   │  └─ 从AllItems删除G
   ├─ 删除容器F
   └─ 从AllItems删除B
   ↓
7. 删除容器C
   ↓
8. 从AllItems删除A
   ↓
9. 完成

最终结果：
- 删除了5个对象：A, B, E, G（物品）+ C, F（容器）
- MainBackpack(D)仍存在，但槽位被清空
```

### 数据流转

**输入**：
- `ItemUID` (FGuid) - 要删除的物品UID

**输出**：
- `bool` - 是否成功删除

**数据变化**：
- `AllItems` 移除该条目（及其容器内的所有物品）
- `Containers` 移除相关容器（如果有）
- 相关槽位引用被清空

### 示例场景

#### 场景1：删除普通物品

```cpp
// 前提条件
// Wood(UID=A) 在 Backpack(UID=B) 槽位0

// 执行
bool bSuccess = InventorySystem->DestroyItem(A);

// 结果：bSuccess = true
// AllItems: 删除条目A
// Containers[B].Slots[0].ItemInstanceUID: A → 无效
// 物品彻底消失
```

#### 场景2：删除带容器的物品（递归删除）

```cpp
// 前提条件
// SubBackpack(UID=A) 在 MainBackpack(UID=D)
// SubBackpack 拥有容器(UID=C)
// 容器C中有 Wood(UID=E) 和 Stone(UID=F)

// 执行
bool bSuccess = InventorySystem->DestroyItem(A);

// 结果：bSuccess = true
// 删除顺序：E → F → C → A
// AllItems: 删除 E, F, A
// Containers: 删除 C
// Containers[D]: 槽位被清空，但D本身仍存在
```

---

## 10. 数据验证流程

### 函数调用
```cpp
bool bIsValid = InventorySystem->ValidateDataIntegrity();
InventorySystem->RepairDataIntegrity();
```

### ValidateDataIntegrity（验证数据一致性）

```
1. ValidateDataIntegrity() 被调用
   ↓
2. 初始化验证标志
   - bIsValid = true
   ↓
3. 【验证所有容器的槽位引用】
   - for each (Container in Containers)
     ↓
     3.1. for each (Slot in Container.Slots)
          ↓
          3.2. if (Slot不为空)
               ↓
               a) 检查物品是否存在
                  - if (!AllItems.Contains(Slot.ItemInstanceUID))
                    → 输出错误 "槽位引用了不存在的物品"
                    → bIsValid = false
               ↓
               b) 如果物品存在，检查位置是否匹配
                  - Item = AllItems[Slot.ItemInstanceUID]
                  - if (Item.CurrentContainerUID != Container.ContainerUID)
                    → 输出错误 "物品位置不匹配（容器UID）"
                    → bIsValid = false
                  - if (Item.CurrentSlotID != Slot.SlotID)
                    → 输出错误 "物品位置不匹配（槽位ID）"
                    → bIsValid = false
   ↓
4. 【验证所有物品的位置引用】
   - for each (Item in AllItems)
     ↓
     4.1. if (Item.IsInContainer())
          ↓
          a) 检查容器是否存在
             - if (!Containers.Contains(Item.CurrentContainerUID))
               → 输出错误 "物品引用了不存在的容器"
               → bIsValid = false
          ↓
          b) 如果容器存在，检查槽位引用是否匹配
             - Container = Containers[Item.CurrentContainerUID]
             - SlotIndex = Container.GetSlotIndexByID(Item.CurrentSlotID)
             - if (SlotIndex == INDEX_NONE)
               → 输出错误 "物品引用了不存在的槽位"
               → bIsValid = false
             - else if (Container.Slots[SlotIndex].ItemInstanceUID != Item.InstanceUID)
               → 输出错误 "槽位没有引用此物品"
               → bIsValid = false
   ↓
5. 【验证容器嵌套关系】
   - for each (Container in Containers)
     ↓
     5.1. if (Container.OwnerItemUID有效)
          ↓
          a) 检查拥有者物品是否存在
             - if (!AllItems.Contains(Container.OwnerItemUID))
               → 输出错误 "容器的拥有者物品不存在"
               → bIsValid = false
          ↓
          b) 检查物品的拥有容器是否匹配
             - Item = AllItems[Container.OwnerItemUID]
             - if (Item.OwnedContainerUID != Container.ContainerUID)
               → 输出错误 "物品的拥有容器不匹配"
               → bIsValid = false
   ↓
6. 输出验证结果
   - if (bIsValid)
     → "库存数据一致性验证通过"
   - else
     → "库存数据一致性验证失败"
   ↓
7. 返回 bIsValid
```

### RepairDataIntegrity（修复数据不一致）

```
1. RepairDataIntegrity() 被调用
   ↓
2. 初始化修复计数
   - RepairCount = 0
   ↓
3. 【修复容器槽位引用】
   - for each (Container in Containers)
     ↓
     3.1. for each (Slot in Container.Slots)
          ↓
          3.2. if (Slot不为空)
               ↓
               a) 检查物品是否存在
                  - if (!AllItems.Contains(Slot.ItemInstanceUID))
                    ↓
                    → 输出日志 "清空无效的槽位引用"
                    → Slot.ItemInstanceUID = 无效
                    → RepairCount++
               ↓
               b) 如果物品存在但位置不匹配
                  - Item = AllItems[Slot.ItemInstanceUID]
                  - if (Item.CurrentContainerUID != Container.ContainerUID ||
                        Item.CurrentSlotID != Slot.SlotID)
                    ↓
                    → 输出日志 "以槽位为准，修复物品位置"
                    → Item.CurrentContainerUID = Container.ContainerUID
                    → Item.CurrentSlotID = Slot.SlotID
                    → RepairCount++
   ↓
4. 【修复物品位置引用】
   - for each (Item in AllItems)
     ↓
     4.1. if (Item.IsInContainer())
          ↓
          a) 检查容器是否存在
             - if (!Containers.Contains(Item.CurrentContainerUID))
               ↓
               → 输出日志 "将物品设为游离状态（容器不存在）"
               → Item.CurrentContainerUID = 无效
               → Item.CurrentSlotID = -1
               → RepairCount++
          ↓
          b) 检查槽位是否存在
             - else
               ↓
               → Container = Containers[Item.CurrentContainerUID]
               → SlotIndex = Container.GetSlotIndexByID(Item.CurrentSlotID)
               → if (SlotIndex == INDEX_NONE)
                 ↓
                 → 输出日志 "将物品设为游离状态（槽位不存在）"
                 → Item.CurrentContainerUID = 无效
                 → Item.CurrentSlotID = -1
                 → RepairCount++
               ↓
               → else if (Slot.ItemInstanceUID != Item.InstanceUID)
                 ↓
                 → 输出日志 "将物品设为游离状态（槽位引用不匹配）"
                 → Item.CurrentContainerUID = 无效
                 → Item.CurrentSlotID = -1
                 → RepairCount++
   ↓
5. 输出修复结果
   - "库存数据一致性修复完成！共修复 RepairCount 个问题"
   ↓
6. 完成
```

### 数据不一致的常见情况

| 不一致类型 | 检测 | 修复方式 | 原因 |
|-----------|------|---------|------|
| **槽位引用不存在的物品** | ValidateDataIntegrity | 清空槽位引用 | 物品被直接从AllItems删除 |
| **物品位置与槽位不匹配** | ValidateDataIntegrity | 以槽位为准修复物品位置 | 更新了槽位但未更新物品 |
| **物品引用不存在的容器** | ValidateDataIntegrity | 将物品设为游离状态 | 容器被删除但物品未更新 |
| **物品引用不存在的槽位** | ValidateDataIntegrity | 将物品设为游离状态 | 槽位ID错误 |
| **槽位未引用物品** | ValidateDataIntegrity | 将物品设为游离状态 | 更新了物品但未更新槽位 |

### 示例场景

#### 场景1：检测并修复槽位引用错误

```cpp
// 异常情况（程序bug导致）
// Containers[A].Slots[0].ItemInstanceUID = B
// 但 AllItems 中不存在 B

// 验证
bool bValid = InventorySystem->ValidateDataIntegrity();
// 结果：bValid = false
// 日志：Error: 槽位引用了不存在的物品: B

// 修复
InventorySystem->RepairDataIntegrity();
// 结果：Containers[A].Slots[0].ItemInstanceUID = 无效
// 日志：修复了1个问题
```

#### 场景2：检测并修复物品位置不匹配

```cpp
// 异常情况
// AllItems[B].CurrentContainerUID = A
// AllItems[B].CurrentSlotID = 5
// 但 Containers[A].Slots[5].ItemInstanceUID = C (不是B)

// 验证
bool bValid = InventorySystem->ValidateDataIntegrity();
// 结果：bValid = false
// 日志：Error: 槽位没有引用此物品

// 修复
InventorySystem->RepairDataIntegrity();
// 结果：AllItems[B] 被设为游离状态
// 日志：将物品设为游离状态（槽位引用不匹配）
```

---

## 📊 **总结：数据流转图**

```
┌─────────────────────────────────────────────────────────┐
│                   UGaiaInventorySubsystem                │
│                                                          │
│  ┌──────────────────┐         ┌──────────────────┐     │
│  │    AllItems      │         │   Containers     │     │
│  │                  │         │                  │     │
│  │ FGuid → FGaia    │         │ FGuid → FGaia    │     │
│  │         ItemInst │         │         Container│     │
│  │                  │         │         Instance │     │
│  │ - InstanceUID    │         │ - ContainerUID   │     │
│  │ - ItemDefID      │         │ - ContainerDefID │     │
│  │ - Quantity       │         │ - Slots[]        │     │
│  │ - CurrentCont... │◄────┐   │ - OwnerItemUID   │     │
│  │ - CurrentSlotID  │     │   │ - ParentContai...│     │
│  │ - OwnedContai... │─────┼──►│                  │     │
│  └──────────────────┘     │   └──────────────────┘     │
│                           │                             │
│  物品存储位置信息          │   容器只存储槽位引用         │
│  单一数据源               │                             │
└───────────────────────────┼─────────────────────────────┘
                            │
                            │ 物品自己知道在哪里
                            │ 容器通过UID引用物品
                            ▼
                    【无数据冗余】
```

---

## 🎯 **关键设计原则**

1. **单一数据源**：物品数据只存在 `AllItems` 中
2. **位置自存储**：物品自己存储位置信息（`CurrentContainerUID`, `CurrentSlotID`）
3. **引用关系**：容器槽位只存储物品UID引用
4. **GUID唯一性**：所有物品和容器都有全局唯一ID
5. **递归处理**：容器嵌套和删除都使用递归
6. **数据一致性**：提供验证和修复机制
7. **游离状态**：支持不在容器中的物品（掉落、装备等）

---

**本文档详细说明了库存系统的所有主要操作流程，可作为开发和调试的参考。** 📖

