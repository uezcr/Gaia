# 物品移动功能测试计划

## 📋 **测试目标**

验证新架构下的物品移动逻辑是否正确工作，包括：
- 容器内移动
- 跨容器移动
- 部分移动（拆分堆叠）
- 堆叠合并
- 物品交换
- 自动槽位分配

---

## ✅ **测试用例清单**

### 1. 容器内移动（完全移动）

**测试场景**：
- 物品在同一个容器内从一个槽位移动到另一个空槽位
- 移动全部数量

**前提条件**：
- Container1 有 20 个槽位
- Item1 (Wood, 数量=10) 在槽位 0
- 槽位 5 为空

**操作**：
```cpp
MoveItem(Item1.InstanceUID, Container1UID, 5, 10)
```

**预期结果**：
- ✅ MovedQuantity = 10
- ✅ RemainingQuantity = 0
- ✅ Result = Success
- ✅ Item1 仍存在，CurrentSlotID: 0 → 5
- ✅ Container1.Slots[0]: 空
- ✅ Container1.Slots[5]: Item1.InstanceUID

**验证点**：
- [ ] 物品的 `CurrentSlotID` 正确更新
- [ ] 原槽位引用被清空
- [ ] 新槽位引用正确设置
- [ ] 物品的 `CurrentContainerUID` 没有改变
- [ ] 物品数量没有改变

---

### 2. 容器内移动（部分移动/拆分）

**测试场景**：
- 物品在同一个容器内拆分，部分数量移动到另一个槽位
- 会创建新的物品实例

**前提条件**：
- Item2 (Wood, 数量=20) 在槽位 1
- 槽位 6 为空

**操作**：
```cpp
MoveItem(Item2.InstanceUID, Container1UID, 6, 8)
```

**预期结果**：
- ✅ MovedQuantity = 8
- ✅ RemainingQuantity = 0
- ✅ Result = Success
- ✅ Item2 保留在槽位 1，数量: 20 → 12
- ✅ 创建新物品实例 Item2_New (新GUID)，数量=8，在槽位 6
- ✅ AllItems 增加 1 个条目

**验证点**：
- [ ] 原物品数量正确减少
- [ ] 创建了新的物品实例（新GUID）
- [ ] 新物品的类型和原物品相同
- [ ] 新物品在正确的槽位
- [ ] AllItems.Num() 增加了 1

---

### 3. 跨容器移动（完全移动）

**测试场景**：
- 物品从一个容器移动到另一个容器
- 移动全部数量

**前提条件**：
- Item3 (Stone, 数量=15) 在 Container1 槽位 3
- Container2 槽位 2 为空

**操作**：
```cpp
MoveItem(Item3.InstanceUID, Container2UID, 2, 15)
```

**预期结果**：
- ✅ MovedQuantity = 15
- ✅ Result = Success
- ✅ Item3.CurrentContainerUID: Container1 → Container2
- ✅ Item3.CurrentSlotID: 3 → 2
- ✅ Container1.Slots[3]: 空
- ✅ Container2.Slots[2]: Item3.InstanceUID

**验证点**：
- [ ] 物品的容器UID正确更新
- [ ] 物品的槽位ID正确更新
- [ ] 原容器槽位被清空
- [ ] 新容器槽位正确引用物品
- [ ] 两个容器都标记为 Dirty

---

### 4. 跨容器移动（部分移动）

**测试场景**：
- 物品从一个容器部分移动到另一个容器
- 会创建新的物品实例

**前提条件**：
- Item4 (Wood, 数量=20) 在 Container1 槽位 4
- Container2 槽位 3 为空

**操作**：
```cpp
MoveItem(Item4.InstanceUID, Container2UID, 3, 8)
```

**预期结果**：
- ✅ MovedQuantity = 8
- ✅ Item4 保留在 Container1，数量: 20 → 12
- ✅ 创建新物品 Item4_New，数量=8，在 Container2 槽位 3

**验证点**：
- [ ] 原物品数量正确减少
- [ ] 原物品位置不变
- [ ] 新物品在目标容器
- [ ] 新物品有新的GUID

---

### 5. 堆叠移动（完全堆叠）

**测试场景**：
- 移动物品到目标槽位，目标槽位有相同类型物品
- 可以完全堆叠

**前提条件**：
- Item5 (Wood, 数量=10) 在 Container1 槽位 0
- Item6 (Wood, 数量=80, 最大堆叠=99) 在 Container2 槽位 0

**操作**：
```cpp
MoveItem(Item5.InstanceUID, Container2UID, 0, 10)
```

**预期结果**：
- ✅ MovedQuantity = 10
- ✅ Result = Success
- ✅ Item5 被删除（DestroyItem）
- ✅ Item6 数量: 80 → 90
- ✅ Container1.Slots[0]: 空
- ✅ AllItems 减少 1 个条目

**验证点**：
- [ ] 源物品被删除
- [ ] 目标物品数量正确增加
- [ ] AllItems.Num() 减少了 1

---

### 6. 堆叠移动（部分堆叠）

**测试场景**：
- 移动物品到目标槽位，目标槽位有相同类型物品
- 目标堆叠空间不足，只能部分堆叠

**前提条件**：
- Item7 (Wood, 数量=20) 在 Container1 槽位 1
- Item8 (Wood, 数量=90, 最大堆叠=99) 在 Container2 槽位 1

**操作**：
```cpp
MoveItem(Item7.InstanceUID, Container2UID, 1, 20)
```

**预期结果**：
- ✅ MovedQuantity = 9（目标只能容纳9个）
- ✅ RemainingQuantity = 11
- ✅ Result = PartialSuccess
- ✅ Item7 数量: 20 → 11（保留在原位置）
- ✅ Item8 数量: 90 → 99（已满）

**验证点**：
- [ ] 返回 PartialSuccess
- [ ] MovedQuantity 正确计算
- [ ] RemainingQuantity 正确计算
- [ ] 源物品保留，数量正确
- [ ] 目标物品达到最大堆叠

---

### 7. 交换移动

**测试场景**：
- 移动物品到目标槽位，目标槽位有不同类型物品
- 执行交换

**前提条件**：
- Item9 (Wood, 数量=10) 在 Container1 槽位 0
- Item10 (Stone, 数量=15) 在 Container2 槽位 0

**操作**：
```cpp
MoveItem(Item9.InstanceUID, Container2UID, 0, 10)
```

**预期结果**：
- ✅ Result = SwapPerformed
- ✅ bWasSwapped = true
- ✅ Item9: Container1槽位0 → Container2槽位0
- ✅ Item10: Container2槽位0 → Container1槽位0

**验证点**：
- [ ] 返回 SwapPerformed
- [ ] 两个物品的位置互换
- [ ] 槽位引用正确交换
- [ ] 数量没有改变

---

### 8. 移动到嵌套容器

**测试场景**：
- 移动物品到目标槽位，目标槽位有背包物品
- 物品应该放入背包的容器中

**前提条件**：
- Item11 (Wood, 数量=5) 在 Container1 槽位 0
- Item12 (Backpack_Small) 在 Container1 槽位 1
  - Item12 拥有容器 SubContainer，有空槽位

**操作**：
```cpp
MoveItem(Item11.InstanceUID, Container1UID, 1, 5)
```

**预期结果**：
- ✅ Result = Success
- ✅ bMovedToContainer = true
- ✅ Item11: Container1 → SubContainer
- ✅ Item11 在 SubContainer 的某个空槽位
- ✅ Container1 槽位 1 仍然是 Item12（背包）

**验证点**：
- [ ] 物品移动到嵌套容器
- [ ] 背包物品位置没变
- [ ] SubContainer.ParentContainerUID 仍然是 Container1

---

### 9. 自动槽位分配

**测试场景**：
- 移动物品但不指定目标槽位（TargetSlotID = -1）
- 系统自动找空槽位

**前提条件**：
- Item13 (Iron, 数量=7) 在 Container1 槽位 0
- Container2 有多个空槽位

**操作**：
```cpp
MoveItem(Item13.InstanceUID, Container2UID, -1, 7)
```

**预期结果**：
- ✅ Result = Success
- ✅ Item13 移动到 Container2 的某个空槽位
- ✅ 找到第一个空槽位

**验证点**：
- [ ] 物品成功移动
- [ ] 自动分配到空槽位
- [ ] 槽位ID有效

---

### 10. 容器已满（失败场景）

**测试场景**：
- 尝试移动物品到已满的容器

**前提条件**：
- Item14 (Wood, 数量=10) 在 Container1 槽位 0
- Container2 所有槽位都有物品

**操作**：
```cpp
MoveItem(Item14.InstanceUID, Container2UID, -1, 10)
```

**预期结果**：
- ✅ Result = ContainerFull
- ✅ MovedQuantity = 0
- ✅ Item14 位置不变

**验证点**：
- [ ] 返回 ContainerFull
- [ ] 物品位置没有改变
- [ ] 没有数据被修改

---

### 11. 体积限制（失败场景）

**测试场景**：
- 尝试移动物品到体积不足的容器

**前提条件**：
- Item15 (BigItem, 体积=100) 在 Container1
- Container2 启用体积限制，剩余体积=50

**操作**：
```cpp
MoveItem(Item15.InstanceUID, Container2UID, 0, 1)
```

**预期结果**：
- ✅ Result = Failed 或 ContainerRejected
- ✅ MovedQuantity = 0
- ✅ ErrorMessage 包含 "体积"

**验证点**：
- [ ] 移动被拒绝
- [ ] 错误信息正确
- [ ] 物品位置不变

---

### 12. 循环引用检测（失败场景）

**测试场景**：
- 尝试创建容器循环引用

**前提条件**：
- MainBackpack (Container1)
  - 包含 SubBackpack (Item16, 拥有 Container2)
- 尝试将 MainBackpack 放入 Container2

**操作**：
```cpp
// 这个操作应该被阻止
AddItemToContainer(MainBackpackItem, Container2)
```

**预期结果**：
- ✅ 操作失败
- ✅ ErrorMessage 包含 "循环引用"

**验证点**：
- [ ] WouldCreateCycle 检测生效
- [ ] 操作被拒绝
- [ ] 数据结构完整性

---

## 🔍 **数据一致性验证**

在每个测试用例执行后，都应该验证：

### 基本一致性检查

```cpp
// 1. 物品位置与槽位引用匹配
for (Item in AllItems) {
    if (Item.IsInContainer()) {
        Container = Containers[Item.CurrentContainerUID]
        Slot = Container.Slots[Item.CurrentSlotID]
        assert(Slot.ItemInstanceUID == Item.InstanceUID)
    }
}

// 2. 槽位引用的物品存在
for (Container in Containers) {
    for (Slot in Container.Slots) {
        if (!Slot.IsEmpty()) {
            assert(AllItems.Contains(Slot.ItemInstanceUID))
        }
    }
}

// 3. 容器嵌套关系正确
for (Container in Containers) {
    if (Container.OwnerItemUID.IsValid()) {
        Item = AllItems[Container.OwnerItemUID]
        assert(Item.OwnedContainerUID == Container.ContainerUID)
    }
}
```

### 可以使用系统自带的验证函数

```cpp
bool bValid = InventorySystem->ValidateDataIntegrity();
assert(bValid == true);
```

---

## 📊 **测试结果记录模板**

### 测试用例 X：[测试名称]

**执行时间**：[日期时间]

**执行结果**：✅ 通过 / ❌ 失败

**详细结果**：
- 前提条件：✅
- 操作执行：✅
- 预期结果 1：✅
- 预期结果 2：✅
- 验证点 1：✅
- 验证点 2：✅
- 数据一致性：✅

**问题/Bug**（如有）：
- 问题描述
- 复现步骤
- 预期行为 vs 实际行为

**日志输出**：
```
[关键日志内容]
```

---

## 🎯 **测试执行步骤**

### 1. 准备测试环境

```cpp
// 在测试关卡中放置 AGaiaInventoryTestActor
// 或在 Blueprint 中调用
UGaiaInventoryTestHelper::RunMoveItemTests(WorldContext);
```

### 2. 运行测试

- 启动游戏（PIE模式）
- 测试自动执行
- 观察日志输出

### 3. 查看结果

- 打开 **Output Log** 窗口
- 过滤 `LogGaia`
- 查找测试结果标记：
  - `✓` 表示通过
  - `✗` 表示失败

### 4. 调试失败用例

如果测试失败：

```bash
# 1. 使用控制台命令查看系统状态
Gaia.Inventory.PrintAllContainers
Gaia.Inventory.PrintAllItems

# 2. 运行数据验证
ValidateDataIntegrity()

# 3. 查看详细日志
# 在 Saved/Logs/Gaia.log 中搜索 "移动" 或 "MoveItem"
```

---

## 🐛 **已知问题和注意事项**

### 问题1：部分移动创建新GUID

**状态**：✅ 已修复

**描述**：部分移动时，新物品实例必须有新的GUID

**修复**：在 `MoveToEmptySlot` 和 `MoveItemWithinContainer` 中添加：
```cpp
if (bIsPartialMove) {
    ItemToMove.InstanceUID = FGuid::NewGuid();
}
```

### 问题2：RemoveItemFromContainer vs DestroyItem

**状态**：✅ 已明确

**说明**：
- `RemoveItemFromContainer`：设置为游离状态，不删除物品
- `DestroyItem`：完全删除物品及其容器

### 问题3：容器嵌套的父容器引用

**状态**：✅ 已修复

**说明**：
- `AddItemToContainer`：设置 `ParentContainerUID`
- `RemoveItemFromContainer`：清空 `ParentContainerUID`
- `DestroyItem`：递归删除嵌套容器

---

## ✅ **测试通过标准**

所有测试用例必须满足：

1. ✅ **功能正确性**：操作结果符合预期
2. ✅ **数据一致性**：`ValidateDataIntegrity()` 返回 true
3. ✅ **无内存泄漏**：所有创建的对象都被正确管理
4. ✅ **日志完整**：关键操作都有日志输出
5. ✅ **错误处理**：失败场景返回正确的错误信息

---

## 📝 **下一步行动**

1. [ ] 运行 `RunBasicTests` 确认基础功能正常
2. [ ] 运行 `RunMoveItemTests` 执行移动测试
3. [ ] 检查每个测试用例的结果
4. [ ] 修复发现的任何问题
5. [ ] 更新测试文档
6. [ ] 提交测试报告

---

**测试计划就绪！现在可以开始执行测试了！** 🚀

运行命令：
```bash
# 在游戏中按 ~ 打开控制台
# 然后运行测试（测试Actor会自动执行）
# 或手动调用
RunBasicTests
```

