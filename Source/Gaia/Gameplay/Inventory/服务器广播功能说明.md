# 服务器广播功能说明

## 📋 **功能概述**

实现了**智能广播系统**，当容器内容发生变化时，自动通知所有相关玩家（容器所有者和正在访问的玩家）刷新库存数据。

---

## 🎯 **设计目标**

### 问题
在多人游戏中，当容器内容发生变化时：
- ❌ 如何通知所有相关玩家？
- ❌ 如何避免通知无关玩家（浪费带宽）？
- ❌ 如何处理私有容器（背包）和世界容器（箱子）？

### 解决方案
✅ **精准广播**：只通知拥有或正在访问容器的玩家  
✅ **自动触发**：物品操作后自动广播  
✅ **双向同步**：源容器和目标容器都会更新  

---

## 🏗️ **架构设计**

### 核心数据结构

```cpp
// GaiaInventorySubsystem.h

/** 容器所有者映射（玩家 -> 拥有的容器列表）*/
TMap<TObjectPtr<APlayerController>, TArray<FGuid>> ContainerOwners;

/** 世界容器访问者映射（容器UID -> 正在访问的玩家）*/
TMap<FGuid, TObjectPtr<APlayerController>> WorldContainerAccessors;
```

---

## 🔧 **核心函数**

### 1. BroadcastContainerUpdate - 广播容器更新

```cpp
void UGaiaInventorySubsystem::BroadcastContainerUpdate(const FGuid& ContainerUID)
```

#### 功能
找到所有与容器相关的玩家，并通知他们刷新库存数据。

#### 执行流程

```
1. 创建玩家集合（使用 TSet 自动去重）
   ↓
2. 添加容器所有者
   ├─ 调用 GetContainerOwners(ContainerUID)
   └─ 添加到集合
   ↓
3. 添加正在访问的玩家
   ├─ 调用 GetContainerAccessor(ContainerUID)
   └─ 添加到集合
   ↓
4. 遍历所有玩家
   ├─ 查找 RPC Component
   ├─ 调用 ServerRequestRefreshInventory_Implementation()
   └─ 客户端收到更新
```

#### 示例

```cpp
// 玩家从箱子拿了一个物品
InventorySystem->MoveItem(ItemUID, PlayerBackpackUID, SlotID, 1);

// 自动广播给：
// 1. 箱子的所有者（如果有）
// 2. 正在访问箱子的玩家（当前玩家）
InventorySystem->BroadcastContainerUpdate(ChestUID);

// 也广播给：
// 1. 背包的所有者（当前玩家）
InventorySystem->BroadcastContainerUpdate(PlayerBackpackUID);
```

---

### 2. RegisterContainerOwner - 注册容器所有者

```cpp
void UGaiaInventorySubsystem::RegisterContainerOwner(
    APlayerController* PlayerController, 
    const FGuid& ContainerUID)
```

#### 功能
将容器标记为玩家拥有（私有容器，如背包）。

#### 使用场景

```cpp
// 玩家登录时，创建背包
void AYourPlayerController::BeginPlay()
{
    if (HasAuthority())
    {
        UGaiaInventorySubsystem* InventorySystem = GetWorld()->GetSubsystem<UGaiaInventorySubsystem>();
        
        // 创建背包
        FGuid BackpackUID = InventorySystem->CreateContainer(TEXT("PlayerBackpack"));
        
        // ✅ 注册为所有者
        InventorySystem->RegisterContainerOwner(this, BackpackUID);
        
        // 同时在 RPC Component 中记录
        UGaiaInventoryRPCComponent* RPCComp = FindComponentByClass<UGaiaInventoryRPCComponent>();
        RPCComp->OwnedContainerUIDs.Add(BackpackUID);
    }
}
```

---

### 3. UnregisterContainerOwner - 注销容器所有者

```cpp
void UGaiaInventorySubsystem::UnregisterContainerOwner(
    APlayerController* PlayerController, 
    const FGuid& ContainerUID)
```

#### 功能
移除玩家对容器的所有权。

#### 使用场景

```cpp
// 玩家断线或删除容器时
void OnPlayerLogout(APlayerController* PC)
{
    UGaiaInventorySubsystem* InventorySystem = GetWorld()->GetSubsystem<UGaiaInventorySubsystem>();
    
    // 获取玩家拥有的所有容器
    TArray<FGuid> OwnedContainers = GetPlayerContainers(PC);
    
    for (const FGuid& ContainerUID : OwnedContainers)
    {
        // 注销所有权
        InventorySystem->UnregisterContainerOwner(PC, ContainerUID);
    }
}
```

---

### 4. GetContainerOwners - 获取容器所有者

```cpp
TArray<APlayerController*> UGaiaInventorySubsystem::GetContainerOwners(
    const FGuid& ContainerUID) const
```

#### 功能
查询哪些玩家拥有指定容器。

#### 返回值
- 拥有该容器的所有玩家列表
- 如果是世界容器（无所有者），返回空数组

#### 示例

```cpp
// 检查谁拥有这个背包
TArray<APlayerController*> Owners = InventorySystem->GetContainerOwners(BackpackUID);

if (Owners.Num() > 0)
{
    UE_LOG(LogGaia, Log, TEXT("背包属于 %s"), *Owners[0]->GetName());
}
else
{
    UE_LOG(LogGaia, Log, TEXT("这是世界容器，无所有者"));
}
```

---

## 🎮 **完整工作流程**

### 场景：玩家A从箱子拿物品到自己背包

```cpp
// ========================================
// 1. 玩家A 拖拽物品
// ========================================

// 客户端 UI
void OnItemDragged(FGuid ItemUID, FGuid TargetBackpackUID, int32 SlotID)
{
    RPCComponent->RequestMoveItem(ItemUID, TargetBackpackUID, SlotID, 1);
}

// ========================================
// 2. RPC 到服务器
// ========================================

void UGaiaInventoryRPCComponent::ServerMoveItem_Implementation(...)
{
    // 执行移动
    FMoveItemResult Result = InventorySystem->MoveItem(ItemUID, TargetBackpackUID, SlotID, 1);
    
    if (Result.IsSuccess())
    {
        // ✅ 广播目标容器更新（玩家背包）
        InventorySystem->BroadcastContainerUpdate(TargetBackpackUID);
        
        // ✅ 广播源容器更新（箱子）
        if (SourceContainerUID.IsValid() && SourceContainerUID != TargetBackpackUID)
        {
            InventorySystem->BroadcastContainerUpdate(SourceContainerUID);
        }
    }
}

// ========================================
// 3. 广播目标容器（背包）
// ========================================

void UGaiaInventorySubsystem::BroadcastContainerUpdate(TargetBackpackUID)
{
    TSet<APlayerController*> PlayersToNotify;
    
    // 找到背包所有者
    TArray<APlayerController*> Owners = GetContainerOwners(TargetBackpackUID);
    // Owners = [PlayerA]
    
    PlayersToNotify.Add(PlayerA);
    
    // 找到正在访问背包的玩家
    APlayerController* Accessor = GetContainerAccessor(TargetBackpackUID);
    // Accessor = nullptr（背包不是世界容器）
    
    // 通知 PlayerA 刷新
    PlayerA->RPCComponent->ServerRequestRefreshInventory_Implementation();
    // PlayerA 的客户端收到更新，UI 刷新
}

// ========================================
// 4. 广播源容器（箱子）
// ========================================

void UGaiaInventorySubsystem::BroadcastContainerUpdate(ChestUID)
{
    TSet<APlayerController*> PlayersToNotify;
    
    // 找到箱子所有者
    TArray<APlayerController*> Owners = GetContainerOwners(ChestUID);
    // Owners = []（箱子是世界容器，无所有者）
    
    // 找到正在访问箱子的玩家
    APlayerController* Accessor = GetContainerAccessor(ChestUID);
    // Accessor = PlayerA（当前正在访问）
    
    PlayersToNotify.Add(PlayerA);
    
    // 通知 PlayerA 刷新
    PlayerA->RPCComponent->ServerRequestRefreshInventory_Implementation();
    // PlayerA 的客户端再次收到更新，箱子UI刷新
}
```

---

## 📊 **数据流向图**

```
玩家A 拖拽物品
    ↓
RequestMoveItem (RPC)
    ↓
ServerMoveItem_Implementation (服务器)
    ↓
InventorySystem->MoveItem()
    ↓
成功移动
    ↓
┌───────────────────────┬───────────────────────┐
│                       │                       │
BroadcastContainerUpdate  BroadcastContainerUpdate
(目标容器：背包)          (源容器：箱子)
    ↓                       ↓
找到所有相关玩家        找到所有相关玩家
- 所有者：PlayerA       - 访问者：PlayerA
    ↓                       ↓
通知 PlayerA 刷新       通知 PlayerA 刷新
    ↓                       ↓
ClientReceiveInventoryData (RPC)
    ↓
PlayerA 的 UI 更新
```

---

## 🔄 **自动广播场景**

### 1. 移动物品

```cpp
void ServerMoveItem_Implementation(...)
{
    if (InventorySystem->MoveItem(...))
    {
        // ✅ 自动广播目标容器
        InventorySystem->BroadcastContainerUpdate(TargetContainerUID);
        
        // ✅ 自动广播源容器（如果不同）
        if (SourceContainerUID != TargetContainerUID)
        {
            InventorySystem->BroadcastContainerUpdate(SourceContainerUID);
        }
    }
}
```

### 2. 添加物品

```cpp
void ServerAddItem_Implementation(...)
{
    if (InventorySystem->AddItemToContainer(Item, ContainerUID))
    {
        // ✅ 自动广播容器更新
        InventorySystem->BroadcastContainerUpdate(ContainerUID);
    }
}
```

### 3. 移除物品

```cpp
void ServerRemoveItem_Implementation(...)
{
    // 先记录源容器
    FGuid SourceContainerUID = Item.CurrentContainerUID;
    
    if (InventorySystem->RemoveItemFromContainer(ItemUID))
    {
        // ✅ 自动广播源容器更新
        InventorySystem->BroadcastContainerUpdate(SourceContainerUID);
    }
}
```

### 4. 销毁物品

```cpp
void ServerDestroyItem_Implementation(...)
{
    // 先记录源容器
    FGuid SourceContainerUID = Item.CurrentContainerUID;
    
    if (InventorySystem->DestroyItem(ItemUID))
    {
        // ✅ 自动广播源容器更新
        InventorySystem->BroadcastContainerUpdate(SourceContainerUID);
    }
}
```

---

## ⚡ **性能优化**

### 1. 使用 TSet 去重

```cpp
void BroadcastContainerUpdate(const FGuid& ContainerUID)
{
    // ✅ 使用 TSet 自动去重
    TSet<APlayerController*> PlayersToNotify;
    
    // 添加所有者
    for (APlayerController* Owner : GetContainerOwners(ContainerUID))
    {
        PlayersToNotify.Add(Owner); // 自动去重
    }
    
    // 添加访问者
    if (APlayerController* Accessor = GetContainerAccessor(ContainerUID))
    {
        PlayersToNotify.Add(Accessor); // 如果已存在，不会重复添加
    }
}
```

### 2. 精准通知

```cpp
// ❌ 错误做法：通知所有玩家
for (APlayerController* PC : AllPlayers)
{
    PC->RefreshInventory(); // 浪费带宽！
}

// ✅ 正确做法：只通知相关玩家
TArray<APlayerController*> Owners = GetContainerOwners(ContainerUID);
APlayerController* Accessor = GetContainerAccessor(ContainerUID);

// 只通知这些玩家
```

### 3. 日志级别控制

```cpp
// 使用 Verbose 级别，避免刷屏
UE_LOG(LogGaia, Verbose, TEXT("[网络广播] 容器 %s 已通知 %d 个玩家"), 
    *ContainerUID.ToString(), PlayersToNotify.Num());
```

---

## 🎯 **使用建议**

### 1. 玩家登录时注册背包

```cpp
void AYourPlayerController::BeginPlay()
{
    if (HasAuthority())
    {
        UGaiaInventorySubsystem* InventorySystem = GetWorld()->GetSubsystem<UGaiaInventorySubsystem>();
        UGaiaInventoryRPCComponent* RPCComp = FindComponentByClass<UGaiaInventoryRPCComponent>();
        
        // 创建并注册背包
        FGuid BackpackUID = InventorySystem->CreateContainer(TEXT("PlayerBackpack"));
        InventorySystem->RegisterContainerOwner(this, BackpackUID);
        RPCComp->OwnedContainerUIDs.Add(BackpackUID);
        
        // 创建并注册装备栏
        FGuid EquipmentUID = InventorySystem->CreateContainer(TEXT("PlayerEquipment"));
        InventorySystem->RegisterContainerOwner(this, EquipmentUID);
        RPCComp->OwnedContainerUIDs.Add(EquipmentUID);
        
        // 同步给客户端
        RPCComp->ServerRequestRefreshInventory_Implementation();
    }
}
```

### 2. 玩家断线时清理

```cpp
void AYourGameMode::OnPlayerDisconnected(APlayerController* PC)
{
    UGaiaInventorySubsystem* InventorySystem = GetWorld()->GetSubsystem<UGaiaInventorySubsystem>();
    UGaiaInventoryRPCComponent* RPCComp = PC->FindComponentByClass<UGaiaInventoryRPCComponent>();
    
    // 注销所有拥有的容器
    for (const FGuid& ContainerUID : RPCComp->OwnedContainerUIDs)
    {
        InventorySystem->UnregisterContainerOwner(PC, ContainerUID);
    }
    
    // 关闭所有打开的世界容器
    for (const FGuid& ContainerUID : RPCComp->OpenWorldContainerUIDs)
    {
        InventorySystem->CloseWorldContainer(PC, ContainerUID);
    }
}
```

---

## 📝 **代码文件变更**

### 修改的文件

1. **GaiaInventorySubsystem.h**
   - ✅ 添加 `ContainerOwners` 成员变量
   - ✅ 添加 4 个新函数

2. **GaiaInventorySubsystem.cpp**
   - ✅ 实现 `BroadcastContainerUpdate`
   - ✅ 实现 `GetContainerOwners`
   - ✅ 实现 `RegisterContainerOwner`
   - ✅ 实现 `UnregisterContainerOwner`
   - ✅ 添加 `#include "GaiaInventoryRPCComponent.h"`

3. **GaiaInventoryRPCComponent.cpp**
   - ✅ `ServerMoveItem` 中调用广播
   - ✅ `ServerAddItem` 中调用广播
   - ✅ `ServerRemoveItem` 中调用广播
   - ✅ `ServerDestroyItem` 中调用广播

---

## ✅ **优势**

1. **智能广播**
   - 只通知相关玩家
   - 自动去重
   - 节省带宽

2. **双向同步**
   - 源容器和目标容器都更新
   - 所有相关玩家都能看到变化

3. **易于使用**
   - 自动触发，无需手动调用
   - 透明的网络同步

4. **可扩展**
   - 可以轻松添加更多广播条件
   - 支持未来的队伍共享功能

---

## 🚀 **未来扩展**

### 可选功能

1. **队伍共享容器**
   ```cpp
   TArray<APlayerController*> GetContainerAccessors(const FGuid& ContainerUID)
   {
       TArray<APlayerController*> Accessors;
       
       // 单人访问
       if (APlayerController* Accessor = GetContainerAccessor(ContainerUID))
       {
           Accessors.Add(Accessor);
       }
       
       // 队友访问（未来）
       // ...
       
       return Accessors;
   }
   ```

2. **增量广播**
   ```cpp
   void BroadcastItemChange(const FGuid& ItemUID, const FGuid& ContainerUID)
   {
       // 只广播单个物品的变化，而不是整个容器
   }
   ```

---

## 🎯 **总结**

✅ **功能完整**：自动广播容器更新  
✅ **性能优化**：精准通知，自动去重  
✅ **易于集成**：自动触发，无需手动调用  
✅ **可扩展**：支持未来功能扩展  

**现在你的多人游戏库存系统支持智能广播了！** 🎉

