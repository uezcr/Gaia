# 库存系统 - 联机同步方案

## 📋 **目录**

1. [当前架构分析](#当前架构分析)
2. [联机需求](#联机需求)
3. [网络同步方案](#网络同步方案)
4. [实现细节](#实现细节)
5. [性能优化](#性能优化)
6. [安全考虑](#安全考虑)

---

## 🔍 **当前架构分析**

### 现有设计

```cpp
// UGaiaInventorySubsystem - GameInstanceSubsystem
class UGaiaInventorySubsystem : public UGameInstanceSubsystem
{
    TMap<FGuid, FGaiaItemInstance> AllItems;        // 所有物品
    TMap<FGuid, FGaiaContainerInstance> Containers; // 所有容器
};
```

### 架构特点

✅ **优势**：
- 集中式管理（单一数据源）
- O(1)查找效率
- GUID唯一标识
- 清晰的数据结构

⚠️ **联机挑战**：
- GameInstanceSubsystem是单机的，不跨服务器
- 没有网络复制支持
- 需要手动实现同步逻辑

---

## 🎯 **联机需求**

### 基本需求

1. **玩家背包同步**
   - 玩家的物品在服务器和客户端保持一致
   - 支持物品的增删改查

2. **容器交互**
   - 箱子、储物柜等世界容器
   - 多玩家同时访问同一容器

3. **物品移动**
   - 拖拽物品
   - 堆叠、拆分、交换
   - 跨容器移动

4. **交易系统**
   - 玩家之间交易物品
   - 掉落拾取

### 网络模式

- **Listen Server** - 主机玩家作为服务器
- **Dedicated Server** - 独立服务器（推荐）
- **客户端预测** - 提升响应速度

---

## 🌐 **网络同步方案**

### 方案A：组件复制（推荐）⭐

#### 架构设计

```
┌─────────────────────────────────────────┐
│  Server (Authority)                     │
│  ┌───────────────────────────────────┐  │
│  │ UGaiaInventorySubsystem           │  │
│  │ - AllItems (Master Data)          │  │
│  │ - Containers (Master Data)        │  │
│  └───────────────────────────────────┘  │
│              ↓ RPC / Replication        │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  Client                                 │
│  ┌───────────────────────────────────┐  │
│  │ UGaiaInventoryComponent (Replicated)│
│  │ - ReplicatedItems                 │  │
│  │ - ReplicatedContainers            │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

#### 核心组件

**1. UGaiaInventoryComponent (ActorComponent)**
```cpp
UCLASS(ClassGroup=(Inventory), meta=(BlueprintSpawnableComponent))
class UGaiaInventoryComponent : public UActorComponent
{
    GENERATED_BODY()

public:
    UGaiaInventoryComponent();

    // 复制的容器UID列表（玩家拥有的容器）
    UPROPERTY(ReplicatedUsing=OnRep_OwnedContainers)
    TArray<FGuid> OwnedContainers;

    // 网络复制设置
    virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
    virtual bool ReplicateSubobjects(UActorChannel* Channel, FOutBunch* Bunch, FReplicationFlags* RepFlags) override;

    // RPC函数
    UFUNCTION(Server, Reliable, WithValidation)
    void ServerMoveItem(const FGuid& ItemUID, const FGuid& TargetContainerUID, int32 TargetSlotID, int32 Quantity);

    UFUNCTION(Client, Reliable)
    void ClientReceiveInventoryUpdate(const TArray<FGaiaItemInstance>& Items, const TArray<FGaiaContainerInstance>& Containers);

private:
    UFUNCTION()
    void OnRep_OwnedContainers();
};
```

**2. UGaiaInventorySubsystem (保留，作为服务器权威数据)**
```cpp
// 服务器端仍使用Subsystem作为数据中心
// 客户端通过Component接收同步数据
```

---

### 方案B：完全RPC

#### 特点
- 所有操作通过RPC
- 客户端不保存数据，只显示
- 服务器权威

#### 优缺点
- ✅ 简单直接
- ✅ 服务器权威，安全
- ❌ 延迟高，每次操作都需要等待服务器响应
- ❌ 网络流量大

---

### 方案C：混合方案（推荐）⭐⭐⭐

#### 核心思路

```
客户端操作 → 本地预测 → 发送RPC → 服务器验证 → 同步结果
     ↓           ↓                            ↓
  立即显示   临时状态                    确认/回滚
```

#### 实现步骤

1. **客户端发起操作**
   - 玩家拖拽物品
   - 本地立即显示移动（预测）
   - 标记为"待确认"状态

2. **发送RPC到服务器**
   ```cpp
   ServerMoveItem(ItemUID, TargetContainer, TargetSlot, Quantity);
   ```

3. **服务器验证**
   - 检查物品是否存在
   - 检查权限（是否是玩家的物品）
   - 检查容器是否允许
   - 执行移动

4. **服务器同步结果**
   - 成功：广播给相关客户端
   - 失败：发送错误给客户端，客户端回滚

---

## 🛠️ **实现细节**

### 1. 数据复制

#### FGaiaItemInstance 网络优化

```cpp
USTRUCT(BlueprintType)
struct FGaiaItemInstance
{
    GENERATED_USTRUCT_BODY()

    // 网络复制的核心字段
    UPROPERTY(Replicated)
    FGuid InstanceUID;

    UPROPERTY(Replicated)
    FName ItemDefinitionID;

    UPROPERTY(Replicated)
    int32 Quantity;

    UPROPERTY(Replicated)
    FGuid CurrentContainerUID;

    UPROPERTY(Replicated)
    int32 CurrentSlotID;

    // 不复制调试字段（客户端可以本地生成）
    UPROPERTY(NotReplicated)
    FString DebugDisplayName;
};
```

#### 自定义序列化

```cpp
// 优化网络传输大小
bool NetSerialize(FArchive& Ar, class UPackageMap* Map, bool& bOutSuccess)
{
    // 只序列化必要字段
    Ar << InstanceUID;
    Ar << ItemDefinitionID;
    Ar << Quantity;
    Ar << CurrentContainerUID;
    Ar << CurrentSlotID;
    
    bOutSuccess = true;
    return true;
}
```

---

### 2. RPC设计

#### 移动物品RPC

```cpp
// 客户端请求移动
UFUNCTION(Server, Reliable, WithValidation)
void ServerMoveItem(
    const FGuid& ItemUID,
    const FGuid& TargetContainerUID,
    int32 TargetSlotID,
    int32 Quantity
);

// 实现
void UGaiaInventoryComponent::ServerMoveItem_Implementation(
    const FGuid& ItemUID,
    const FGuid& TargetContainerUID,
    int32 TargetSlotID,
    int32 Quantity)
{
    // 1. 权限检查
    if (!CanPlayerAccessItem(GetOwner(), ItemUID))
    {
        ClientMoveItemFailed(EMoveItemResult::InvalidTarget, TEXT("无权限"));
        return;
    }

    // 2. 调用Subsystem执行移动
    UGaiaInventorySubsystem* InventorySystem = GetGameInstance()->GetSubsystem<UGaiaInventorySubsystem>();
    FMoveItemResult Result = InventorySystem->MoveItem(ItemUID, TargetContainerUID, TargetSlotID, Quantity);

    // 3. 同步结果
    if (Result.IsSuccess())
    {
        // 广播给相关玩家
        BroadcastInventoryUpdate();
    }
    else
    {
        // 通知客户端失败
        ClientMoveItemFailed(Result.Result, Result.ErrorMessage);
    }
}

// 验证函数
bool UGaiaInventoryComponent::ServerMoveItem_Validate(
    const FGuid& ItemUID,
    const FGuid& TargetContainerUID,
    int32 TargetSlotID,
    int32 Quantity)
{
    // 基本验证，防止作弊
    return Quantity > 0 && Quantity <= 999;
}

// 客户端接收失败通知
UFUNCTION(Client, Reliable)
void ClientMoveItemFailed(EMoveItemResult Result, const FString& ErrorMessage);
```

---

### 3. 容器访问权限

#### 权限系统

```cpp
enum class EContainerAccessLevel : uint8
{
    Private,        // 私有（只有所有者）
    Team,          // 队伍
    Public         // 公开
};

// 检查访问权限
bool CanPlayerAccessContainer(APlayerController* Player, const FGuid& ContainerUID)
{
    FGaiaContainerInstance Container;
    if (!FindContainerByUID(ContainerUID, Container))
    {
        return false;
    }

    // 检查所有权
    if (Container.OwnerItemUID.IsValid())
    {
        FGaiaItemInstance OwnerItem;
        if (FindItemByUID(Container.OwnerItemUID, OwnerItem))
        {
            // 检查物品所属玩家
            return IsPlayerOwnsItem(Player, OwnerItem.InstanceUID);
        }
    }

    // 世界容器（箱子等）
    // TODO: 检查世界容器的访问权限
    return true;
}
```

---

### 4. 同步策略

#### 按需同步（推荐）

```cpp
// 只同步玩家相关的数据
void SyncPlayerInventory(APlayerController* Player)
{
    UGaiaInventoryComponent* InventoryComp = Player->FindComponentByClass<UGaiaInventoryComponent>();
    if (!InventoryComp)
        return;

    TArray<FGaiaItemInstance> PlayerItems;
    TArray<FGaiaContainerInstance> PlayerContainers;

    // 收集玩家拥有的容器
    for (const FGuid& ContainerUID : InventoryComp->OwnedContainers)
    {
        FGaiaContainerInstance Container;
        if (FindContainerByUID(ContainerUID, Container))
        {
            PlayerContainers.Add(Container);

            // 收集容器内的物品
            TArray<FGaiaItemInstance> Items = GetItemsInContainer(ContainerUID);
            PlayerItems.Append(Items);
        }
    }

    // 发送给客户端
    InventoryComp->ClientReceiveInventoryUpdate(PlayerItems, PlayerContainers);
}
```

#### 增量同步

```cpp
// 只同步变化的数据
struct FInventoryDelta
{
    TArray<FGuid> AddedItems;
    TArray<FGuid> RemovedItems;
    TArray<FGaiaItemInstance> ModifiedItems;
};

UFUNCTION(Client, Reliable)
void ClientReceiveInventoryDelta(const FInventoryDelta& Delta);
```

---

## ⚡ **性能优化**

### 1. 网络带宽优化

#### 压缩技术

```cpp
// 使用位压缩
struct FCompressedItemData
{
    uint16 ItemDefIDHash;  // 2字节 (而不是FName的完整字符串)
    uint8 Quantity;        // 1字节 (如果MaxStackSize < 256)
    uint8 SlotID;          // 1字节
    // 总共 4字节 vs 原来的 ~40字节
};
```

#### 批量更新

```cpp
// 不要每次操作都RPC，而是批量发送
TArray<FPendingInventoryOperation> PendingOps;

void FlushPendingOperations()
{
    if (PendingOps.Num() > 0)
    {
        ServerBatchOperations(PendingOps);
        PendingOps.Empty();
    }
}
```

---

### 2. 更新频率控制

```cpp
// 限制同步频率
float LastSyncTime = 0.f;
const float MinSyncInterval = 0.1f; // 最多每0.1秒同步一次

void RequestSync()
{
    float CurrentTime = GetWorld()->GetTimeSeconds();
    if (CurrentTime - LastSyncTime >= MinSyncInterval)
    {
        ServerRequestInventoryUpdate();
        LastSyncTime = CurrentTime;
    }
}
```

---

### 3. 相关性优化

```cpp
// 只同步相关玩家
// 例如：打开同一个箱子的玩家

class UGaiaInventoryComponent : public UActorComponent
{
    virtual bool IsNetRelevantFor(
        const AActor* RealViewer,
        const AActor* ViewTarget,
        const FVector& SrcLocation) const override
    {
        // 自定义相关性逻辑
        return Super::IsNetRelevantFor(RealViewer, ViewTarget, SrcLocation);
    }
};
```

---

## 🔒 **安全考虑**

### 1. 服务器权威

```cpp
// 所有重要操作必须在服务器验证
void UGaiaInventoryComponent::ServerMoveItem_Implementation(...)
{
    // ✅ 好的做法：服务器验证
    if (!HasAuthority())
    {
        return; // 只在服务器执行
    }

    // 验证操作合法性
    if (!ValidateMoveOperation(...))
    {
        return;
    }

    // 执行操作
    ExecuteMove(...);
}
```

### 2. 防作弊

```cpp
// 检查操作频率（防止刷物品）
TMap<APlayerController*, FAntiCheatData> AntiCheatTracking;

struct FAntiCheatData
{
    int32 OperationCount;
    float WindowStartTime;
};

bool CheckOperationRate(APlayerController* Player)
{
    FAntiCheatData& Data = AntiCheatTracking.FindOrAdd(Player);
    
    float CurrentTime = GetWorld()->GetTimeSeconds();
    if (CurrentTime - Data.WindowStartTime > 1.0f)
    {
        // 重置窗口
        Data.OperationCount = 0;
        Data.WindowStartTime = CurrentTime;
    }

    Data.OperationCount++;
    
    // 最多每秒20次操作
    if (Data.OperationCount > 20)
    {
        UE_LOG(LogGaia, Warning, TEXT("玩家 %s 操作频率异常"), *Player->GetName());
        return false;
    }

    return true;
}
```

### 3. 权限验证

```cpp
// 严格的权限检查
bool ValidateMoveOperation(APlayerController* Player, const FGuid& ItemUID, const FGuid& TargetContainer)
{
    // 1. 检查物品所有权
    if (!IsPlayerOwnsItem(Player, ItemUID))
    {
        UE_LOG(LogGaia, Warning, TEXT("玩家 %s 尝试移动不属于自己的物品"), *Player->GetName());
        return false;
    }

    // 2. 检查目标容器访问权限
    if (!CanPlayerAccessContainer(Player, TargetContainer))
    {
        return false;
    }

    // 3. 检查操作合理性（距离、视线等）
    if (!IsContainerInRange(Player, TargetContainer))
    {
        return false;
    }

    return true;
}
```

---

## 📝 **实现步骤（推荐路线）**

### 阶段1：基础架构（1-2周）

1. ✅ 创建 `UGaiaInventoryComponent`
2. ✅ 实现基本的网络复制
3. ✅ 添加 `OwnedContainers` 字段
4. ✅ 实现 `GetLifetimeReplicatedProps`

### 阶段2：RPC实现（1周）

5. ✅ 实现 `ServerMoveItem` RPC
6. ✅ 实现 `ClientReceiveInventoryUpdate`
7. ✅ 添加权限验证

### 阶段3：客户端预测（1周）

8. ✅ 实现本地预测移动
9. ✅ 实现回滚机制
10. ✅ 添加"待确认"状态UI

### 阶段4：优化（1-2周）

11. ✅ 增量同步
12. ✅ 网络压缩
13. ✅ 频率限制
14. ✅ 防作弊系统

### 阶段5：测试（持续）

15. ✅ 单机测试
16. ✅ 局域网测试
17. ✅ 高延迟测试
18. ✅ 压力测试

---

## 🎯 **下一步讨论**

我们可以讨论以下方面：

1. **选择哪个方案？**
   - 方案A：组件复制
   - 方案C：混合方案（推荐）

2. **客户端预测**
   - 是否需要？
   - 如何实现回滚？

3. **世界容器**
   - 箱子如何同步？
   - 多玩家同时访问？

4. **交易系统**
   - 玩家间交易
   - 掉落拾取

5. **性能目标**
   - 支持多少玩家？
   - 每个玩家多少物品？

---

**准备好开始实现联机功能了吗？告诉我你的想法和需求！** 🚀

