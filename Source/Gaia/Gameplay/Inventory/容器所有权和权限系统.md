# 容器所有权和权限系统

## 📋 **系统概述**

实现了**完整的容器所有权和权限控制系统**，支持多种容器类型（私有、世界、共享、交易），并在网络层面提供了全面的安全保护。

---

## 🎯 **设计目标**

### 问题
在多人游戏中，如何确保：
- ❌ 玩家只能访问自己的私有容器（背包）？
- ❌ 世界容器（箱子）可以被任何人访问，但避免冲突？
- ❌ 共享容器（公会仓库、房屋箱子）可以授权特定玩家访问？
- ❌ 防止玩家通过网络修改访问不属于他们的物品？

### 解决方案
✅ **容器类型系统**：4种容器类型，满足不同需求  
✅ **权限检查**：在所有RPC函数中验证玩家权限  
✅ **授权列表**：支持为共享容器授权特定玩家  
✅ **自动设置**：注册所有者时自动设置容器类型  

---

## 🏗️ **容器类型系统**

### 容器所有权类型枚举

```cpp
enum class EContainerOwnershipType : uint8
{
    /** 私有容器 - 只有所有者可以访问（玩家背包、装备栏） */
    Private,
    
    /** 世界容器 - 任何人都可以访问，但同时只能一人打开（野外箱子、宝箱） */
    World,
    
    /** 共享容器 - 有所有者，可以授权其他人访问（房屋箱子、公会仓库） */
    Shared,
    
    /** 交易容器 - 临时容器，用于玩家间交易 */
    Trade
};
```

### 容器实例数据结构

```cpp
struct FGaiaContainerInstance
{
    // ... 其他字段 ...
    
    /** 容器所有权类型 */
    UPROPERTY(BlueprintReadWrite, Category = "Ownership")
    EContainerOwnershipType OwnershipType = EContainerOwnershipType::World;

    /** 授权访问的玩家UID列表（仅用于Shared类型容器） */
    UPROPERTY(BlueprintReadWrite, Category = "Ownership")
    TArray<FGuid> AuthorizedPlayerUIDs;
};
```

---

## 🔧 **核心API**

### 1. 玩家UID获取

```cpp
/**
 * 获取玩家的唯一UID
 * @param PlayerController 玩家控制器
 * @return 玩家的唯一标识符（从PlayerState获取）
 */
static FGuid GetPlayerUID(APlayerController* PlayerController);
```

**实现逻辑**：
1. 优先从 `PlayerState->GetUniqueId()` 生成确定性GUID
2. 回退到 `NetPlayerIndex`
3. 最后生成随机UID（仅本地单机）

**特点**：
- 确定性：同一个玩家总是得到相同的UID
- 网络安全：基于服务器端的PlayerState

### 2. 容器类型管理

```cpp
/**
 * 设置容器的所有权类型
 */
void SetContainerOwnershipType(const FGuid& ContainerUID, EContainerOwnershipType OwnershipType);

/**
 * 获取容器的所有权类型
 */
EContainerOwnershipType GetContainerOwnershipType(const FGuid& ContainerUID) const;
```

**使用示例**：
```cpp
// 创建一个世界容器
FGuid ChestUID = InventorySystem->CreateContainer(TEXT("WorldChest"));
// 默认是 World 类型

// 创建玩家背包并设置为私有
FGuid BackpackUID = InventorySystem->CreateContainer(TEXT("PlayerBackpack"));
InventorySystem->RegisterContainerOwner(PlayerController, BackpackUID);
// 自动设置为 Private 类型

// 创建房屋箱子（共享容器）
FGuid HouseChestUID = InventorySystem->CreateContainer(TEXT("HouseChest"));
InventorySystem->RegisterContainerOwner(HouseOwner, HouseChestUID);
InventorySystem->SetContainerOwnershipType(HouseChestUID, EContainerOwnershipType::Shared);
```

### 3. 授权访问管理

```cpp
/**
 * 授权玩家访问共享容器
 */
void AuthorizePlayerAccess(const FGuid& ContainerUID, APlayerController* PlayerController);

/**
 * 取消玩家访问共享容器的授权
 */
void RevokePlayerAccess(const FGuid& ContainerUID, APlayerController* PlayerController);
```

**使用示例**：
```cpp
// 房主授权朋友访问自己的房屋箱子
InventorySystem->AuthorizePlayerAccess(HouseChestUID, FriendPlayer);

// 取消授权
InventorySystem->RevokePlayerAccess(HouseChestUID, FriendPlayer);
```

### 4. 权限检查

```cpp
/**
 * 检查玩家是否可以访问指定容器
 */
bool CanPlayerAccessContainer(
    APlayerController* PlayerController, 
    const FGuid& ContainerUID, 
    FString& OutErrorMessage) const;

/**
 * 检查玩家是否可以操作指定物品
 */
bool CanPlayerAccessItem(
    APlayerController* PlayerController, 
    const FGuid& ItemUID, 
    FString& OutErrorMessage) const;
```

---

## 🛡️ **权限验证逻辑**

### 容器访问权限矩阵

| 容器类型 | 所有者 | 授权玩家 | 其他玩家 |
|---------|--------|---------|---------|
| **Private** | ✅ 可访问 | ❌ 拒绝 | ❌ 拒绝 |
| **World** | ✅ 可访问 | ✅ 可访问 | ✅ 可访问（独占） |
| **Shared** | ✅ 可访问 | ✅ 可访问 | ❌ 拒绝 |
| **Trade** | ✅ 可访问（交易双方） | - | ❌ 拒绝 |

### 权限检查流程

```
玩家尝试访问容器
    ↓
获取容器类型
    ↓
┌─────────────┬──────────────┬──────────────┬──────────────┐
│   Private   │    World     │    Shared    │    Trade     │
└─────────────┴──────────────┴──────────────┴──────────────┘
      ↓              ↓              ↓              ↓
  检查所有者      允许访问       检查所有者      检查交易方
      ↓                           或授权          ↓
  是？允许                          ↓           是？允许
  否？拒绝                      是？允许         否？拒绝
                                否？拒绝
```

### 实现细节

**容器权限检查** (`CanPlayerAccessContainer`):
```cpp
switch (Container->OwnershipType)
{
case EContainerOwnershipType::Private:
    // 只有所有者可以访问
    if (Owner != PlayerController)
        return false; // "这是私有容器，只有所有者可以访问"
    break;

case EContainerOwnershipType::World:
    // 任何人都可以访问（独占访问由 WorldContainerAccessors 控制）
    break;

case EContainerOwnershipType::Shared:
    // 所有者或授权玩家可以访问
    if (Owner != PlayerController && !Container->IsPlayerAuthorized(PlayerUID))
        return false; // "你没有权限访问此共享容器"
    break;

case EContainerOwnershipType::Trade:
    // TODO: 实现交易容器的权限检查
    break;
}
```

**物品权限检查** (`CanPlayerAccessItem`):
```cpp
// 如果物品在容器中，检查容器访问权限
if (Item->IsInContainer())
{
    if (!CanPlayerAccessContainer(PlayerController, Item->CurrentContainerUID))
        return false; // "无法访问物品所在的容器"
}
// 如果物品是游离状态（掉落、装备等）
else
{
    // TODO: 添加游离物品的权限检查（例如：检查物品是否在玩家附近）
}
```

---

## 🌐 **网络安全保护**

### RPC函数中的权限验证

所有服务器端RPC函数都已添加权限检查：

#### ServerMoveItem
```cpp
void UGaiaInventoryRPCComponent::ServerMoveItem_Implementation(...)
{
    // 权限检查：源物品
    if (!InventorySystem->CanPlayerAccessItem(PC, ItemUID, PermissionError))
    {
        ClientOperationFailed(403, PermissionError);
        return;
    }

    // 权限检查：目标容器
    if (!InventorySystem->CanPlayerAccessContainer(PC, TargetContainerUID, PermissionError))
    {
        ClientOperationFailed(403, PermissionError);
        return;
    }

    // 执行移动...
}
```

#### ServerAddItem
```cpp
void UGaiaInventoryRPCComponent::ServerAddItem_Implementation(...)
{
    // 权限检查：目标容器
    if (!InventorySystem->CanPlayerAccessContainer(PC, ContainerUID, PermissionError))
    {
        ClientOperationFailed(403, PermissionError);
        return;
    }

    // 执行添加...
}
```

#### ServerRemoveItem & ServerDestroyItem
```cpp
void UGaiaInventoryRPCComponent::Server*Item_Implementation(...)
{
    // 权限检查：物品
    if (!InventorySystem->CanPlayerAccessItem(PC, ItemUID, PermissionError))
    {
        ClientOperationFailed(403, PermissionError);
        return;
    }

    // 执行操作...
}
```

#### ServerOpenWorldContainer
```cpp
void UGaiaInventoryRPCComponent::ServerOpenWorldContainer_Implementation(...)
{
    // TryOpenWorldContainer 内部会调用 CanPlayerAccessContainer
    if (!InventorySystem->TryOpenWorldContainer(PC, ContainerUID, ErrorMessage))
    {
        ClientOperationFailed(403, ErrorMessage);
        return;
    }
}
```

### 错误码规范

| 错误码 | 含义 |
|-------|------|
| `403` | 权限不足 (Forbidden) |
| `1` | 系统不可用 |
| `4-7` | 操作失败（具体错误） |

---

## 📝 **使用场景示例**

### 场景1：玩家背包（私有容器）

```cpp
// 服务器端：玩家登录时创建背包
void OnPlayerLogin(APlayerController* Player)
{
    UGaiaInventorySubsystem* InventorySystem = GetWorld()->GetSubsystem<UGaiaInventorySubsystem>();
    
    // 创建玩家背包
    FGuid BackpackUID = InventorySystem->CreateContainer(TEXT("PlayerBackpack"));
    
    // 注册所有者（自动设置为Private类型）
    InventorySystem->RegisterContainerOwner(Player, BackpackUID);
    
    // 创建初始物品
    FGaiaItemInstance Sword = InventorySystem->CreateItemInstance(TEXT("IronSword"), 1);
    InventorySystem->AddItemToContainer(Sword, BackpackUID);
}

// 结果：只有该玩家可以访问自己的背包
// 其他玩家尝试访问会收到错误："这是私有容器，只有所有者可以访问"
```

### 场景2：野外宝箱（世界容器）

```cpp
// 地图设计师放置宝箱
void SpawnWorldChest(FVector Location)
{
    UGaiaInventorySubsystem* InventorySystem = GetWorld()->GetSubsystem<UGaiaInventorySubsystem>();
    
    // 创建世界容器（默认就是World类型）
    FGuid ChestUID = InventorySystem->CreateContainer(TEXT("WorldChest"));
    
    // 添加战利品
    FGaiaItemInstance Gold = InventorySystem->CreateItemInstance(TEXT("Gold"), 100);
    InventorySystem->AddItemToContainer(Gold, ChestUID);
}

// 结果：
// - 任何玩家都可以打开
// - 同时只能一个玩家打开（独占访问）
// - 玩家A打开时，玩家B会收到："容器正被 PlayerA 使用"
```

### 场景3：房屋箱子（共享容器）

```cpp
// 玩家购买房屋后设置箱子
void SetupHouseChest(APlayerController* HouseOwner, FGuid HouseChestUID)
{
    UGaiaInventorySubsystem* InventorySystem = GetWorld()->GetSubsystem<UGaiaInventorySubsystem>();
    
    // 注册房主为所有者
    InventorySystem->RegisterContainerOwner(HouseOwner, HouseChestUID);
    
    // 设置为共享类型
    InventorySystem->SetContainerOwnershipType(HouseChestUID, EContainerOwnershipType::Shared);
}

// 房主授权朋友访问
void AuthorizeFriend(FGuid HouseChestUID, APlayerController* Friend)
{
    UGaiaInventorySubsystem* InventorySystem = GetWorld()->GetSubsystem<UGaiaInventorySubsystem>();
    
    // 授权访问
    InventorySystem->AuthorizePlayerAccess(HouseChestUID, Friend);
}

// 结果：
// - 房主可以访问
// - 授权的朋友可以访问
// - 其他玩家尝试访问会收到："你没有权限访问此共享容器"
```

### 场景4：公会仓库（共享容器）

```cpp
// 公会创建仓库
void CreateGuildStorage(APlayerController* GuildLeader, TArray<APlayerController*> GuildMembers)
{
    UGaiaInventorySubsystem* InventorySystem = GetWorld()->GetSubsystem<UGaiaInventorySubsystem>();
    
    // 创建公会仓库
    FGuid GuildStorageUID = InventorySystem->CreateContainer(TEXT("GuildStorage"));
    
    // 注册公会会长为所有者
    InventorySystem->RegisterContainerOwner(GuildLeader, GuildStorageUID);
    
    // 设置为共享类型
    InventorySystem->SetContainerOwnershipType(GuildStorageUID, EContainerOwnershipType::Shared);
    
    // 授权所有公会成员
    for (APlayerController* Member : GuildMembers)
    {
        InventorySystem->AuthorizePlayerAccess(GuildStorageUID, Member);
    }
}

// 公会成员退出时取消授权
void OnPlayerLeaveGuild(FGuid GuildStorageUID, APlayerController* Player)
{
    UGaiaInventorySubsystem* InventorySystem = GetWorld()->GetSubsystem<UGaiaInventorySubsystem>();
    
    // 取消授权
    InventorySystem->RevokePlayerAccess(GuildStorageUID, Player);
}
```

---

## ⚙️ **自动化行为**

### 自动类型设置

**调用 `RegisterContainerOwner` 时**：
- 如果容器当前是 `World` 类型
- 自动升级为 `Private` 类型

```cpp
void RegisterContainerOwner(APlayerController* PlayerController, const FGuid& ContainerUID)
{
    // 设置所有者
    ContainerOwnerMap.Add(ContainerUID, PlayerController);
    
    // 如果是World类型，自动升级为Private
    if (Container->OwnershipType == EContainerOwnershipType::World)
    {
        Container->OwnershipType = EContainerOwnershipType::Private;
    }
}
```

**好处**：
- 简化API调用
- 避免忘记设置类型
- 符合"私有容器必须有所有者"的约定

---

## 🔍 **调试和日志**

所有权限相关操作都有详细的日志输出：

```
[所有权] 设置容器 XXXXXXXX 的所有权类型为: 0 (Private)
[授权] 玩家 PlayerA (UID: YYYYYYYY) 已被授权访问容器 XXXXXXXX
[网络权限] 玩家 PlayerB 尝试移动物品 ZZZZZZZZ 失败: 这是私有容器，只有所有者可以访问
[网络权限] 玩家 PlayerC 尝试打开容器 XXXXXXXX 失败: 你没有权限访问此共享容器
```

---

## 🎓 **最佳实践**

### ✅ 推荐做法

1. **明确容器类型**
   ```cpp
   // 创建容器后立即设置类型
   FGuid ContainerUID = InventorySystem->CreateContainer(TEXT("Chest"));
   InventorySystem->SetContainerOwnershipType(ContainerUID, EContainerOwnershipType::Shared);
   ```

2. **利用自动设置**
   ```cpp
   // Private容器使用RegisterContainerOwner自动设置
   InventorySystem->RegisterContainerOwner(Player, BackpackUID);
   // 自动变为Private类型
   ```

3. **及时清理授权**
   ```cpp
   // 玩家离线/退出公会时清理授权
   InventorySystem->RevokePlayerAccess(GuildStorageUID, Player);
   ```

4. **处理错误消息**
   ```cpp
   FString ErrorMessage;
   if (!InventorySystem->CanPlayerAccessContainer(Player, ContainerUID, ErrorMessage))
   {
       // 向玩家显示友好的错误提示
       ShowNotification(Player, ErrorMessage);
   }
   ```

### ❌ 避免的做法

1. **不要直接修改容器类型而不设置所有者**
   ```cpp
   // 错误：设置为Private但没有所有者
   InventorySystem->SetContainerOwnershipType(UID, EContainerOwnershipType::Private);
   // 没有调用 RegisterContainerOwner
   ```

2. **不要绕过权限检查**
   ```cpp
   // 错误：直接调用底层API而不检查权限
   InventorySystem->MoveItem(ItemUID, ContainerUID, 0, 1); // 服务器端可能会失败
   
   // 正确：通过RPC组件，自动包含权限检查
   RPCComponent->RequestMoveItem(ItemUID, ContainerUID, 0, 1);
   ```

3. **不要忘记处理Trade类型**
   ```cpp
   // 当前Trade类型的权限检查未完全实现
   // 实现交易系统时需要补充
   ```

---

## 🚀 **未来扩展**

### 计划中的功能

1. **交易容器权限**
   - 实现交易双方的权限验证
   - 支持交易确认机制

2. **团队容器**
   - 支持临时组队时的共享容器
   - 队伍解散时自动清理权限

3. **权限级别**
   - 只读权限（可查看不可修改）
   - 管理员权限（可授权其他人）

4. **审计日志**
   - 记录所有权限变更
   - 记录容器访问历史

---

## 📚 **相关文档**

- **[RPCComponent使用指南.md](RPCComponent使用指南.md)** - RPC组件的使用说明
- **[容器独占访问功能说明.md](容器独占访问功能说明.md)** - 独占访问机制
- **[服务器广播功能说明.md](服务器广播功能说明.md)** - 广播系统
- **[基于WorldSubsystem的联机方案.md](基于WorldSubsystem的联机方案.md)** - 整体网络架构

---

## 📄 **总结**

✅ **完整的权限系统**：涵盖4种容器类型和完善的权限检查  
✅ **网络安全**：所有RPC函数都包含权限验证  
✅ **灵活的授权**：支持共享容器的多人访问  
✅ **自动化管理**：智能的类型设置和所有者管理  
✅ **易于使用**：简洁的API和清晰的错误提示  

这套权限系统为多人在线游戏提供了坚实的安全基础！🎉

